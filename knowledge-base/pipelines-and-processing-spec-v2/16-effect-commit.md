# v2 — Effect Commit (как применяются эффекты)

Этот документ описывает **слой commit**: как набор `Effect[]`, возвращённый операциями, **валидируется** и **применяется** к каноническим слоям v2 (prompt/turn/artifacts) в детерминированном порядке.

Детали применения конкретных `effect.type` (например, точные правила позиционирования prompt-вставок, форматы patch, trimming и т.п.) описываются **в отдельных документах** и не являются частью этого раздела.

Связанные документы:

- Effects (контракт `Effect`): [`15-effects.md`](./15-effects.md)
- Operation (execute vs commit, зависимости, статусность): [`10-operation.md`](./10-operation.md)
- Run (фазы и барьер): [`30-run.md`](./30-run.md)
- Artifacts (инварианты хранения): [`40-artifacts.md`](./40-artifacts.md)

---

## 0) Scope

Этот документ фиксирует:

- **когда** запускается commit-слой внутри `Run`;
- **какие входы** он получает;
- **какие проверки** обязан делать (policy/валидация/ограничения по хукам);
- **какой порядок** применения должен быть (deterministic ordering);
- **какой выход** он возвращает (commit report) для наблюдаемости и статуса `Run`.

Этот документ **не** фиксирует:

- точные алгоритмы конкретных `effect.type` (handlers);
- конкретные форматы `blocks/meta` и patch-форматов;
- конкретные правила конфликтов/слияний (если они появятся) — только рамку.

---

## 1) Главная идея

Commit-слой — это **единая точка контроля**, которая превращает “декларативные эффекты” в реальные изменения:

- prompt-time данных (effective prompt),
- канона текущего turn,
- состояния артефактов (persisted/run_only).

Инвариант v2: **эффекты применяются только при `OperationResult.status="done"`**.

---

## 2) Когда вызывается commit (две точки)

Внутри одного `Run` commit вызывается **как минимум** в двух местах:

### 2.1 Commit A — перед `main LLM` (только `before_main_llm`)

Цель: подготовить “черновик” effective prompt к моменту старта `main LLM`.

- применяются только эффекты, допустимые **до** main LLM:
  - `prompt.*`
  - (опционально) `artifact.*` — если продукт допускает запись/обновление артефактов до main LLM и это влияет на prompt через prompt-inclusion
  - `turn.*` — только user-часть (если такие эффекты есть и политика разрешает)

### 2.2 Commit B — после `main LLM` (только `after_main_llm`)

Цель: канонизировать результат текущего хода и обновить артефакты по итогам main LLM.

- применяются эффекты, допустимые после main LLM:
  - `turn.*` (user и assistant часть по политике)
  - `artifact.*`
  - любые `prompt.*` здесь считаются **policy error** (в v2 prompt после старта main LLM менять нельзя)

> Примечание: в терминах событий `Run` это может выглядеть как `commit.before_main_llm` и `commit.after_main_llm`, даже если транспорт событий пока не типизирован.

---

## 3) Вход commit-слоя

Commit-слой получает:

- **контекст Run** (минимум: `runId`, `trigger`, текущий `hook`, идентификаторы `chat/branch/turn`, политика/лимиты);
- **список операций, которые должны были участвовать**, и их результаты:
  - `operationId`
  - `required`
  - `order`
  - `dependsOn[]`
  - `status`
  - `effects[]` (только если `status="done"`, иначе считаем пусто)
- **доступ к таргетам применения** (интерфейсы):
  - prompt builder (для prompt-time данных),
  - turn canonicalizer (для variants/blocks/meta),
  - artifact store (persisted/run_only),
  - (опционально) журнал/логгер для bounded summaries.

---

## 4) Нормализация эффектов (done-only)

Перед применением commit-слой строит “очередь эффектов”:

- если операция `status="done"` → берём её `effects[]`;
- если `status="skipped|error|aborted"` → считаем `effects=[]` (ноль эффектов).

Нормативно: операция не должна “частично” менять канон вне commit. Даже если она делала побочные действия внутри, канонические изменения v2 считаются применёнными только через commit.

---

## 5) Commit-очередь (deterministic ordering)

Commit-слой обязан применять эффекты в детерминированном порядке, независимо от конкурентности исполнения:

1) зависимости: если `B dependsOn A`, то **все эффекты** `A` применяются раньше **любых эффектов** `B`;
2) среди готовых к применению операций: сортировка по `order` (меньше раньше);
3) tie-break: `operationId` (лексикографически).

> Важно: commit-порядок задаётся **на уровне операций**, а не отдельных эффектов. Внутри одной операции эффекты применяются в порядке массива `effects[]` (если продукт не введёт отдельное правило).

---

## 6) Валидация и policy checks

Перед применением (и/или на каждом эффекте) commit-слой обязан проверять:

- **hook constraints**:
  - `prompt.*` допустимы только в commit A (до main LLM);
  - `turn.assistant_*` допустимы только в commit B (после main LLM);
- **boundedness**: размеры `content/payload/value/blocks`, количество эффектов, лимиты логирования;
- **artifact invariants**:
  - корректный `tag`,
  - соответствие `persisted/run_only` и доступности хранилища,
  - дополнительные проверки, если продукт их вводит (например запрет записи persisted до main LLM).

При нарушении policy/валидации commit-слой фиксирует ошибку применения (см. раздел 7).

---

## 7) Ошибки commit и влияние на статус Run (рамка)

Commit-слой может завершить применение для конкретного эффекта статусом:

- `applied` — применён успешно
- `skipped` — не применён по политике/условию (например “неактуально”, “no-op”) *(опционально)*
- `error` — не применён из-за ошибки (policy/validation/conflict/storage)

Нормативная рамка влияния ошибок коммита на `Run`:

- если commit-ошибка случилась в эффектах операции, помеченной `required=true`, то `Run` должен стать **failed**:
  - если это commit A (до main LLM) — main LLM **не должен стартовать** (аналог барьера), `failedType="before_barrier"` или отдельная детализация (TBD);
  - если это commit B (после main LLM) — main LLM уже выполнен, но `Run` становится failed с `failedType="after_main_llm"`.

Если операция `required=false`, commit-ошибка **не обязана** ронять `Run`, но должна быть видима в отчёте и логах (policy продукта).

> Детализация кодов ошибок (`policy_error`, `validation_error`, `artifact_conflict`, `storage_error`, ...) — продуктовая, но коды должны быть стабильными.

---

## 8) Commit report (наблюдаемость)

Commit-слой должен возвращать отчёт, который позволяет объяснить:

- что было кандидатами на применение,
- что реально применилось,
- что не применилось и почему.

Минимальная форма (рекомендуется):

```ts
type AppliedEffect = {
  operationId: string;
  effectIndex: number; // индекс эффекта внутри OperationResult.effects
  effectType: string;  // значение Effect.type

  status: "applied" | "skipped" | "error";
  error?: { code: string; message: string };
};

type CommitReport = {
  hook: "before_main_llm" | "after_main_llm";
  applied: AppliedEffect[];
};
```

---

## 9) Контракты обработчиков (handlers) (TBD)

Конкретное применение `effect.type` реализуется обработчиками, например:

- `prompt.*` → PromptBuilder
- `turn.*` → TurnCanonicalizer
- `artifact.*` → ArtifactStore

Для каждого `effect.type` отдельный документ должен описывать:

- точный алгоритм применения;
- конфликтные случаи и их решение;
- boundedness/лимиты;
- что именно логируем.


# v2 — OperationProfile (хранилище операций)

Этот документ фиксирует **что такое `OperationProfile` как DB‑сущность**: какие поля он хранит и **какие базовые проверки можно/нужно делать при сохранении**.

Ключевой принцип: `OperationProfile` — **максимально “глупое” хранилище** (контейнер), он **ничего не исполняет**, **не планирует** и **не “строит Run”**. Исполнение и планирование относятся к процессу `Run`/оркестратору и описываются отдельно.

Связанные документы:

- Термины: [`00-terminology.md`](./00-terminology.md)
- Operation (контракт и модель исполнения): [`10-operation.md`](./10-operation.md)
- Run (жизненный цикл исполнения): [`30-run.md`](./30-run.md)

> Примечание: в v2 термин “Pipeline” считаем legacy. `OperationProfile` — это просто сущность, которая **объединяет набор операций**.

## 0) Scope и допущения

Этот документ:

- описывает `OperationProfile` как **persisted сущность** (БД/JSON — не принципиально);
- задаёт **минимальные правила валидации профиля при сохранении**;
- **не** описывает планирование/исполнение/commit эффектов — это не роль профиля.

## 1) Что такое OperationProfile (в одном абзаце)

**`OperationProfile`** — это **контейнер для набора операций** (идентификатор операции + её `OperationConfig`) и минимальных метаданных (имя/описание/флаги).

Профиль:

- хранится как отдельная сущность в базе;
- используется как входные данные для `Run` (оркестратор читает профиль и запускает операции согласно их конфигам);
- может быть **полностью выключен** флагом `enabled=false` (тогда `Run` считается “без операций” и работает как “чистая генерация main LLM”).

## 2) Составные части: Definition vs Config vs Profile

### 2.1 OperationDefinition (каталог операций)

`OperationDefinition` — “что это за операция” (идентичность + диспетчеризация на handler):

- `operationId` (стабильный)
- `kind`
- `name`, `description?`, `capabilities?` (опционально)

`OperationDefinition` живёт в каталоге (builtin и/или расширяемом) и отдельно от профиля.

### 2.2 OperationConfig (настройка операции в профиле)

`OperationConfig` — “как операция настроена в этом профиле”:

- `enabled`, `required`
- `hooks[]`, `triggers[]?`
- `order`, `dependsOn[]?`
- `params`
- `debug?`

Подробности контракта и исполнения/commit: см. `10-operation.md`.

### 2.3 OperationProfile (композиция)

Профиль **только связывает** `operationId` с `OperationConfig` и хранит их набор как единое целое (без “логики исполнения” внутри профиля).

## 3) Схема данных (минимальная)

Ниже — рекомендуемая минимальная форма. Конкретное хранение (DB/JSON) и ключи могут отличаться, но смысл должен совпадать.

```ts
type OperationProfile = {
  profileId: string; // стабильный идентификатор (например "default", "rp-light", "builtin:story")
  name: string;
  description?: string;

  // Можно выбрать профиль, но полностью выключить его (Run без операций).
  enabled: boolean; // default true

  // Режим исполнения операций внутри одного hook.
  // `concurrent`: операции могут выполняться конкурентно (асинхронно) с учётом зависимостей `dependsOn`.
  // `sequential`: операции выполняются строго последовательно (по одной) в детерминированном порядке (см. `30-run.md`).
  executionMode: "concurrent" | "sequential"; // default "concurrent"

  // Resettable id для привязки persistent-хранилища между run.
  // Пользователь может перегенерировать его, чтобы начать новую “сессию профиля”.
  operationProfileSessionId: string; // например UUID

  // Для миграций/совместимости (рекомендуется):
  version?: number;

  // Набор операций и их конфигурации:
  operations: Array<{
    operationId: string;
    config: OperationConfig;
  }>;
};
```

Рекомендация реализации: для удобства валидации держать быстрый индекс `operationId -> config`, но на уровне контракта это не обязательно.

## 4) Валидация OperationProfile при сохранении (нормативно)

Валидация профиля выполняется **в момент сохранения/обновления** профиля (save‑time validation).

Цели:

- отлавливать очевидно сломанные конфиги заранее;
- гарантировать базовые инварианты v2 (например уникальность `art.<tag>` в рамках профиля).

### 4.1 Валидация структуры

- `profileId` не пустой.
- `enabled` задан и является boolean.
- `executionMode` задан и является `"concurrent" | "sequential"` (если поле не хранится явно, считается `"concurrent"`).
- `operationProfileSessionId` не пустой.
- `operations[]` задан (пустой список допустим, если продукт позволяет “профиль без операций”).
- внутри `operations[]` **нет дубликатов `operationId`**.

### 4.2 Валидация ссылок на OperationDefinition (рекомендуется)

Для каждого `operationId` в профиле рекомендуется проверять, что существует `OperationDefinition` в доступном каталоге (builtin/плагины).

- если определения нет — это **ошибка сохранения** (профиль не должен считаться валидным).

> Примечание: если продукт допускает “черновики профиля” без доступного `OperationDefinition` (например, при импортировании), это должно быть явно описано отдельной политикой.

### 4.3 Валидация `dependsOn` (базовая)

`dependsOn` в `OperationConfig` — это **ссылки по `operationId` внутри того же профиля**.

Базовые правила:

- каждая ссылка в `dependsOn[]` должна указывать на **существующий `operationId`** в этом же `OperationProfile`.
- (рекомендуется) `dependsOn` не должен ссылаться на саму операцию.

Дополнительные проверки (рекомендуется, но могут быть отложены):

- **межхуковые зависимости запрещены**: если `A.config.dependsOn` указывает на `B`, то должно быть возможно, что `A` и `B` выполняются в рамках **одного hook** (в v2 хуки разделены барьером main LLM). Практически это означает, что `dependsOn` не должен “пересекать” хуки. Политика точной проверки зависит от того, допускаем ли мы `hooks[]` с несколькими значениями и как именно оркестратор интерпретирует такие конфиги.
- **циклы зависимостей**: проверка ацикличности (DAG) полезна, но статус этой проверки **TBD** (обсудим позже).

### 4.4 Валидация `order` (базовая)

- `order` обязателен и должен быть числом.

Диапазоны/шаги `order` не нормируются спекой.

### 4.5 Валидация артефактных коллизий (`art.<tag>`) (нормативно)

В v2 действует правило: **`tag` должен быть уникальным в рамках одного `OperationProfile`**.

Это означает: если две операции в одном профиле потенциально пишут один и тот же `art.<tag>`, это ошибка конфигурации и профиль не должен сохраняться как валидный.

Как валидировать:

- валидатор должен уметь вывести **целевой тег записи** для каждой операции из её конфигурации/определения (например через `OperationDefinition.capabilities` или нормализованное поле в `OperationConfig.params`);
- если целевой `tag` нельзя определить статически — это **не рекомендуется** в v2; такие операции должны **явно декларировать** `tag`, иначе профиль считается невалидным (или “непроверяемым” — если продукт вводит такую категорию).

> Связанный инвариант v2: “одна операция пишет только в один `art.<tag>`”. На уровне профиля это обычно означает, что операция должна явно декларировать единственный `writeArtifactTag` (или эквивалент) в своих параметрах/схеме.

## 5) OperationProfileSession (хранилище между Run)

### 5.1 Что такое OperationProfileSession

**OperationProfileSession** — логическое “хранилище состояния”, которое:

- живёт **между** `Run` (переживает множество запусков);
- используется для хранения/доступа к persisted‑артефактам и их истории, а также любых “между‑run” данных, которые нужны операциям;
- выбирается/создаётся по **ключу сессии**.

### 5.2 Ключ сессии (нормативно)

Сессия однозначно определяется кортежем:

- `chatId`
- `branchId`
- `operationProfileRef` (или эквивалент: `profileId` + версия/источник)
- `operationProfileSessionId` (resettable id из профиля)

Если по такому ключу сессии нет — она создаётся. Если есть — переиспользуется.

### 5.3 Для чего нужен `operationProfileSessionId` (мотивация)

Пользователь может существенно изменить профиль/параметры так, что старые persisted‑артефакты станут семантически несовместимыми.

Решение v2:

- перегенерация `operationProfileSessionId` создаёт **новую** `OperationProfileSession`,
- тем самым “обнуляя” видимость persisted‑состояния/историй для последующих `Run`,
- без удаления старых данных (они остаются привязаны к старой сессии по политике продукта).

## 6) Ошибки профиля и время их обнаружения (рекомендуется)

- **Ошибки профиля (save‑time)**: неизвестный `operationId`, плохие `dependsOn`, коллизии `art.<tag>` и т.п. — должны обнаруживаться **при сохранении** профиля и не допускать сохранения невалидного конфига.
- **Ошибки исполнения (run‑time)**: provider error, template render, parse и т.п. — это уже `OperationRun.status="error"` во время `Run`.

## 7) Пример (схематично)

Профиль “RP basic” (как хранилище):

- хранит список операций (id + config), например:
  - `builtin:is_combat_guard` (hooks=`before_main_llm`, required=true, order=10) → пишет `art.is_combat`
  - `builtin:combat_rag` (hooks=`before_main_llm`, required=false, order=20, dependsOn guard) → может `skipped`
  - `builtin:augmentation_notes` (hooks=`before_main_llm`, required=false, order=30)
  - `builtin:world_state_update` (hooks=`after_main_llm`, required=true, order=10) → пишет `art.world_state`

При сохранении такой профиль валидируется (уникальность `art.*`, корректность ссылок `dependsOn`, структура). Исполнение и планирование относятся к `Run`.


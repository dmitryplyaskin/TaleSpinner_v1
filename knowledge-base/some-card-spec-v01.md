https://github.com/kwaroran/character-card-spec-v3/blob/main/SPEC_V3.md есть такая спецификация для карточек для ролевой игры например в sillytavern. Я делаю свое приложение аналог, оно будет поддерживать v3, но v3 мне кажется слишком ограниченным и character ориентированным. Есть еще формат charX, но это просто глупых архив для хранения множества картинок, хранит он сам по себе не очень много сверх спеки в3.

я хочу улучшить и расширить этот формат спецификации под свои задачи. Как минимум добавить конкретные сценарии под каждое приветствие при необходимости. Это позволить обходить нелепости, когда приходится прятать сценарий в приветствии, что бы юзер не мог прочесть его и так далее.

Так же я в целом хочу отойти от персонажа ориентированности, что бы "card" позволяла хранить в себе большие сложные миры, со множеством персонажей, локаций, ссылки на изображения и прочее и так далее. Что бы это можно было использовать для полноценных ролевых систем и хранить в ней всю нужную информацию и так далее.

В общем, что ты можешь предложить мне и как мне качественно сделать новую хорошую спеку стандарт который я буду использовать для своих целей?

---

Архитектура и спецификация универсального стандарта игровых миров для систем интерактивного повествования на базе больших языковых моделейЭволюция форматов хранения данных для ИИ-ролеплея прошла путь от примитивных текстовых описаний до структурированных JSON-контейнеров, таких как Character Card V2 и V3. Однако современные требования к глубине погружения и сложности повествования выявили критические ограничения существующих стандартов. Анализ спецификации Character Card V3 (CCV3) показывает, что, несмотря на внедрение строгой типизации и поддержку ассетов, формат остается «персонаже-центричным», что делает его малопригодным для реализации масштабных миров с множеством локаций, динамических сценариев и взаимосвязанных неигровых персонажей (NPC).1 Настоящий отчет представляет собой глубокое исследование и предложение по созданию нового стандарта — Nexus World Specification (NWS), который расширяет возможности CCV3 и CHARX, превращая «карточку» в полноценную игровую систему.Ограничения Character Card V3 и необходимость парадигмального сдвигаТекущая спецификация V3 была разработана как ответ на потребность в стандартизации передачи ассетов и метаданных создателя.1 Она успешно решает задачи автоматической валидации через Pydantic-модели и обеспечивает целостность данных при экспорте в PNG или CHARX.1 Тем не менее, базовая структура данных всё еще опирается на объект CharacterCardV3Data, где центральное место занимают имя, описание личности и приветствие одного конкретного героя.Для разработки систем, способных поддерживать сложные миры, необходимо отойти от концепции «карточки персонажа» в пользу «манифеста мира». В рамках CCV3 сценарий (Scenario) является глобальным свойством, что вынуждает создателей контента прибегать к ухищрениям: прятать специфические вводные данные в приветствиях (Greetings) или использовать макросы для динамической подмены переменных.4 Это часто приводит к логическим нестыковкам, когда при переключении между альтернативными приветствиями ИИ продолжает опираться на устаревший контекст сценария.6Сравнительный анализ архитектурных подходовХарактеристикаCharacter Card V3Nexus World Specification (Предлагаемый стандарт)Центральная сущностьОдиночный персонажМировая система (World Manifest)Связь приветствия и сценарияГлобальный сценарийСценарий, специфичный для приветствия (Scenario-per-Greeting)Структура локацийОпционально через LorebookИнтегрированные узлы графа (Spatial Nodes)Управление NPCОдин основной + NPC в LorebookРеестр активных сущностей (Entity Registry)Хранение данныхJSON внутри PNG или CHARXМногоуровневый пакет (Extended Resource Container)Скрытая информацияОтсутствует (доступна через JSON)Поля видимости (Visibility/Secret Layers)Архитектура Entity Component System (ECS) для игровых мировДля перехода к «миро-центричности» предлагается внедрение архитектурного паттерна Entity Component System (ECS), который широко применяется в современной разработке видеоигр для управления сложными состояниями.7 В контексте ИИ-ролеплея это означает отказ от жестких классов персонажей в пользу набора гибких компонентов, которые могут быть привязаны к любой сущности, будь то человек, локация или магический предмет.Сущность (Entity) в данном стандарте представляет собой лишь уникальный идентификатор (UUID). Вся смысловая нагрузка распределяется по компонентам. Например, NPC будет обладать компонентами Identity, Personality, DialogueStyle и LocationBinding.7 Локация, в свою очередь, получит компоненты SpatialData, EnvironmentalDescription и Atmosphere.9Преимущества ECS для систем на базе LLMПрименение ECS позволяет системе динамически собирать промпт для модели, включая в него только те компоненты, которые релевантны текущей сцене. Математическая модель релевантности контекста может быть выражена формулой:$$C_{prompt} = \sum_{e \in E_{active}} f(C_{identity}(e), C_{relevance}(e, context))$$Где $E_{active}$ — множество сущностей в текущей зоне видимости, а $f$ — функция веса, определяющая приоритетность включения данных компонента в контекстное окно.10 Такой подход предотвращает «засорение» памяти ИИ информацией о персонажах, которые находятся в другом конце игрового мира, тем самым повышая качество генерации и снижая расход токенов.12Решение проблемы консистентности сценариев через Greeting-Scenario MappingОдной из центральных задач, поставленных в запросе, является устранение «нелепостей», связанных с глобальным сценарием. В текущих реализациях, таких как SillyTavern, пользователь видит список альтернативных приветствий, каждое из которых может подразумевать совершенно разные начальные условия: от мирной встречи в таверне до сражения на поле боя.5 Однако, поскольку поле scenario остается неизменным, ИИ часто путается, пытаясь совместить текущее действие с глобальной установкой.Новый стандарт вводит объект ContextualGreeting, который заменяет массив строк alternate_greetings. Структура этого объекта включает в себя:initial_message: Текст первого сообщения.13local_scenario: Описание ситуации, специфичное только для этого старта. Оно может полностью заменять глобальный сценарий или дополнять его.6embedded_lore: Список ссылок на записи Lorebook, которые должны быть активированы принудительно (Always On) при выборе данного приветствия.14secret_info: Поле, содержащее информацию, которую ИИ должен знать, но которая не должна отображаться пользователю в интерфейсе (например, истинные намерения собеседника или скрытая угроза).15Это позволяет реализовать «скрытые сценарии», когда игрок выбирает приветствие «Вы встречаете странника», не зная, что в поле local_scenario прописана его принадлежность к культу убийц. Приложение-аналог должно корректно парсить эти поля и подавать их в системный промпт как неоспоримые факты ситуации.16Моделирование больших миров: Локации и Пространственная ЛогикаДля поддержки масштабных приключений формат должен включать явное описание топологии мира. В отличие от CCV3, где локации описываются фрагментарно в Lorebook, Nexus World Specification предлагает выделенный реестр Locations.18Каждая локация в спецификации — это не просто текст, а узел графа с определенными свойствами:Связи (Adjacency): Массив ID соседних локаций, позволяющий ИИ и приложению понимать пути перемещения.Постоянные сущности (Static Entities): Список NPC и предметов, которые «привязаны» к этому месту.18Ассеты окружения (Environmental Assets): Ссылки на фоновые изображения, эмбиент-звуки и даже 3D-модели (через расширенный формат CHARX).3Правила области (Zone Rules): Набор инструкций для ИИ, действующих только здесь (например, «В этом лесу нельзя использовать огонь»).20Компонент ЛокацииТип данныхОписаниеidUUIDУникальный ключ для ссылок внутри системы.nameStringНазвание, используемое в промпте и интерфейсе.descriptionTextОсновное описание для LLM.13parent_idUUIDСсылка на регион/город для иерархического вложения.21image_uriURIСсылка на визуальный ассет (локальный или внешний).3visibilityEnumОпределяет, видит ли игрок описание локации до входа в неё.Такая структура позволяет приложению автоматически обновлять chat_background и системные инструкции при перемещении персонажа, создавая ощущение живого пространства.22Управление NPC и сложными взаимодействиямиПереход от одной карточки к миру требует системы управления множеством персонажей. В предложенной спецификации основной персонаж (Main Character) является лишь точкой входа, в то время как реестр NPC_Registry хранит данные о других обитателях мира.23Для каждого NPC в реестре определяются не только базовые черты (внешность, личность), но и динамические параметры:Отношения (Relationship Graph): Матрица весов, описывающая отношение данного NPC к игроку и другим NPC (например, trust: 0.8, fear: 0.2).25Осведомленность (Knowledge Base): Список записей из мирового Lorebook, которыми владеет данный персонаж. Это критически важно для предотвращения ситуаций, когда случайный крестьянин знает тайные планы короля только потому, что эта информация есть в общем контексте.12Состояние (Status): Флаги здоровья, магической энергии или текущего местоположения.Использование XML-тегов для разделения данных различных NPC в промпте является лучшей практикой для современных моделей, таких как Claude 4.5 или Gemini 3.0.12 Пример формирования блока данных для модели:XML<npc_data id="merchant_001">
<identity>Торговец ценностями, жадный, но честный.</identity>
<current_mood>Раздраженный (потому что игрок долго торгуется)</current_mood>
<inventory> asset://items/ancient_coin.json </inventory>
</npc_data>
Расширение формата CHARX: Контейнер ресурсов нового поколенияФормат CHARX в его текущем виде представляет собой ZIP-архив с JSON-файлом card.json и папкой ассетов.3 Для реализации полноценных ролевых систем этот формат должен быть трансформирован в иерархическую структуру файловой системы игрового модуля.Предлагаемая структура Nexus-контейнераmanifest.json: Содержит метаданные модуля, версию спецификации, зависимости и ссылки на основные точки входа (стартовый сценарий, основной мир).world/: Папка с JSON-файлами локаций и глобальных настроек мира.entities/: Папка с карточками персонажей (NPC) и описаниями предметов.lorebook/: Наборы данных World Info, разбитые по категориям для оптимизации поиска.assets/: Расширенная структура папок для медиафайлов:images/ (PNG, AVIF, WebP).3audio/ (MP3, OGG для эмбиента и голосов).video/ (MP4 для динамических фонов).code/ (Lua или JS скрипты для автоматизации механик).3dialogue/: Скрипты ветвления (например, в формате Ink или Yarn Spinner) для реализации жестких квестовых цепочек, которые ИИ должен соблюдать.29Использование URI-схемы embedded:// внутри JSON позволяет обращаться к этим файлам независимо от того, где развернуто приложение — локально или на сервере.3Логика ветвления и интеграция с внешними движкамиДля превращения системы в «полноценную ролевую систему» недостаточно просто передавать текст. Необходимо внедрение логических проверок. Использование специализированных языков, таких как Ink, позволяет задавать условия, которые ИИ будет учитывать при генерации ответа.29Например, если в сценарии указано, что для входа в замок нужно иметь «Золотой пропуск», приложение может проверить наличие этого предмета в инвентаре игрока (компонент Inventory сущности игрока) и передать ИИ соответствующую инструкцию: «Игрок предъявил пропуск, стража должна его пропустить».15 Это снимает с ИИ задачу по самостоятельному отслеживанию инвентаря, в чем модели часто ошибаются.Математика вероятностей и проверок (RNG)Для систем, претендующих на сходство с TTRPG (D&D, Pathfinder), спецификация должна поддерживать поля stats и mechanics. Приложение может выполнять броски кубиков и вставлять результат в контекст:$$Result = Roll(d20) + Modifier(Attribute) > Difficulty$$Результат такой проверки подается ИИ в скрытом системном сообщении: ``. ИИ затем описывает это действие художественно.17Безопасность и управление доступом к информацииПользователь справедливо указал на проблему «прятания сценария» от игрока. В Nexus World Specification эта задача решается через введение уровней доступа (Access Layers). В JSON-схеме каждое поле может иметь аттрибут visibility:public: Видно игроку в интерфейсе редактирования/просмотра.internal: Видно только приложению и ИИ, скрыто от игрока в обычном режиме (предназначено для сюрпризов и сюжетных поворотов).private: Зашифрованные данные или данные, доступные только после выполнения определенных условий в игре.Это позволяет создавать карточки-приключения, где игрок не знает всей предыстории мира, пока не «раскроет» её через взаимодействие с NPC или исследование локаций.12Промпт-инжиниринг и когнитивная нагрузка на модельПри работе с «большими сложными мирами» критически важно учитывать лимиты контекста и внимание модели. Исследования показывают, что LLM лучше всего усваивают информацию, расположенную в начале и конце промпта.32Nexus World Specification предписывает приложению-аналогу следующую структуру формирования итогового промпта:System Core: Неизменяемые правила мира и стиля игры.Scenario Overlay: Текущий активный сценарий (включая Greeting-specific override).5Active Environment: Описание текущей локации и присутствующих NPC (Entity Component Data).Relevant Lore: Выборка из Lorebook по ключевым словам или через векторный поиск (RAG).10Hidden Knowledge: Слой секретной информации для текущей сцены.Chat History: Последние N сообщений для поддержания нити диалога.14Для минимизации когнитивной нагрузки на модель спецификация поддерживает «ленивую загрузку» сущностей. Если NPC находится в другой комнате, его полная биография не попадает в контекст, пока игрок не откроет дверь. Вместо этого в памяти хранится лишь краткий «индекс» сущности: id: servant_01, status: nearby, relation: neutral.12Реализация и стандартизацияЧтобы создать качественную спецификацию, которую можно использовать для своих целей, необходимо следовать принципам модульности. Рекомендуется использовать JSON Schema для формального описания всех объектов, что обеспечит совместимость с инструментами разработки на Python, JS и Rust.1Шаги к созданию Nexus World Standard (NWS)Создание базового репозитория: Аналогично CCV3, необходимо опубликовать SPEC.md и наборы JSON-схем.2Разработка CLI-инструментов: Утилиты для сборки и разборки Nexus-пакетов, валидации связей между локациями и NPC.1Демонстрационный модуль: Создание эталонного «мира-примера», демонстрирующего работу сценариев на каждое приветствие и пространственную логику.33Документирование API: Описание того, как приложение должно обрабатывать макросы, условия ветвления и скрытые поля.34Nexus World Specification — это не просто расширение V3, это переход к пониманию ИИ-ролеплея как полноценной игровой среды. Интеграция принципов ECS, графовых моделей локаций и контекстно-зависимых сценариев позволяет преодолеть текущие ограничения индустрии и создать платформу для по-настоящему глубоких и живых миров. Такой стандарт обеспечит долголетие игровым проектам, позволяя им расти от простых чат-ботов до масштабных цифровых вселенных, где каждый персонаж и каждый камень имеют свою историю, скрытую от глаз игрока, но известную всевидящему «мастеру» в лице искусственного интеллекта.

---

Для качественного перехода от «карточки персонажа» (CCV3) к «модулю мира» необходимо изменить саму структуру корневого объекта. В V3 всё завязано на одном `data`, описывающем личность. В новой спецификации (назовем её **Nexus World Spec**) корень — это манифест, который управляет реестрами сущностей и логическими связями.

Ниже представлены конкретные схемы данных, которые решают ваши задачи: разделение сценариев и приветствий, многоперсонажность и пространственную логику.

### 1. Корневой манифест (World Manifest)

Вместо описания одного персонажа, корень содержит ссылки на глобальные реестры. Это позволяет приложению загружать только нужные части мира, экономя контекстное окно LLM.

```json
{
  "spec": "nexus-v1",
  "metadata": {
    "title": "Забытый Элизиум",
    "author": "Explorer_01",
    "version": "1.0.5"
  },
  "entry_point": {
    "default_entity": "uuid-hero-001",
    "default_location": "uuid-loc-tavern"
  },
  "entities": {}, // Реестр персонажей (NPC и Игрок)
  "locations": {}, // Реестр локаций (Комнаты, города, регионы)
  "greeting_bundles":, // Массив сложных сценариев старта
  "assets": {
    "images": "assets/images/",
    "sounds": "assets/audio/"
  }
}

```

### 2. Схема контекстного приветствия (Scenario-per-Greeting)

Это решает проблему «скрытых сценариев». Каждое приветствие теперь — это не просто строка, а объект `GreetingBundle`.

**Что здесь хорошего:** Пользователь в интерфейсе видит только `display_text`, но при выборе этого варианта приложение подставляет в системный промпт `local_scenario` и `secret_context`, о которых игрок не знает.

```json
{
  "id": "start-001",
  "label": "Встреча в лесу",
  "display_text": "Странник в плаще преграждает вам путь: 'Стой, путник. Дальше дороги нет.'",
  "logic": {
    "local_scenario": "Вы находитесь на границе Запретного Леса. Страж проверяет, нет ли у игрока меток культа.",
    "secret_context": "На самом деле страж смертельно ранен и блефует, чтобы скрыть вход в убежище.",
    "forced_lore": ["lore-forest-curse", "lore-guard-faction"], // Принудительная активация записей лора
    "initial_state": {
      "location_id": "uuid-loc-forest-gate",
      "active_npc": ["uuid-npc-guard-01"]
    }
  }
}
```

### 3. Схема локации (Spatial Node)

В CCV3 локации — это просто текст в Lorebook. В Nexus локация — это узел графа с правилами.

**Что здесь хорошего:** Поле `adjacency` позволяет приложению понимать, куда игрок может пойти, и автоматически менять фон или музыку при переходе.

```json
{
  "id": "uuid-loc-tavern",
  "name": "Таверна 'Хромой Бес'",
  "description": "Задымленное помещение, пахнет элем и старым деревом.",
  "adjacency": ["uuid-loc-street-main", "uuid-loc-cellar"], // Связи с соседними локациями
  "static_entities": ["uuid-npc-barkeeper"], // Кто здесь находится всегда
  "zone_rules": "В таверне запрещено обнажать оружие. NPC реагируют агрессивно на магию.",
  "visuals": {
    "background": "embeded://images/tavern_main.avif",
    "ambient_audio": "embeded://audio/tavern_noise.mp3"
  }
}
```

### 4. Схема сущности/NPC (Entity Registry)

В отличие от V3, где есть один «главный» персонаж, здесь все NPC равноправны. Приложение подает ИИ данные только о тех, кто находится «в сцене».

```json
{
  "id": "uuid-npc-guard-01",
  "identity": {
    "name": "Эрик",
    "role": "Раненый страж",
    "personality": "Гордый, подозрительный, изнуренный."
  },
  "knowledge": {
    "private_lore": ["secret-key-gate"], // Что знает только этот NPC
    "shared_lore": ["world-history-basic"]
  },
  "stats": {
    "health": 20,
    "loyalty": 0.5
  },
  "dialogue_style": "Говорит хриплым шепотом, часто прерывается на кашель."
}
```

### Сравнительный анализ: Что хорошо, а что плохо

| Параметр     | Character Card V3 (Плохо для миров)                      | Nexus World Spec (Хорошо для миров) |
| ------------ | -------------------------------------------------------- | ----------------------------------- |
| **Сценарии** | Один глобальный на всю карточку. Сложно менять контекст. |

| Индивидуальный `local_scenario` для каждого варианта старта.

|
| **Секреты** | Если сценарий в приветствии, пользователь его видит.

| Поле `secret_context` скрыто от игрока, но подается ИИ.

|
| **NPC** | Ограничены Lorebook'ом, часто путаются.

| Полноценные объекты со своим стилем речи и базой знаний.

|
| **Пространство** | ИИ не понимает, где находится, если не прописать в чате.

| Графовая структура локаций с `zone_rules`.

|
| **Ресурсы** | Плоская структура CHARX (просто куча картинок).

| Иерархический контейнер (папки `entities/`, `world/`, `dialogue/`).

|

### Рекомендация по реализации

1. **Используйте UUID:** Не ссылайтесь на сущности по именам (они могут повторяться), используйте уникальные ключи для связки персонажей и локаций.

2. **Слой видимости (Visibility Layers):** Введите в JSON поля `visibility: "player"` и `visibility: "ai_only"`. Это позволит вам качественно управлять интригой, не боясь, что игрок прочтет спойлер в настройках карточки.

3. **Логика Ink/Yarn:** Для «полноценных ролевых систем» добавьте поле `script_file`, куда можно положить файл формата **Ink**. Это позволит приложению проверять условия (например, наличие предмета в инвентаре) перед тем, как ИИ сгенерирует ответ.

Эта спецификация превращает «карточку» в самодостаточный игровой модуль, который можно импортировать в ваше приложение и сразу получить живой мир с логикой перемещения и глубокими NPC.

---

Понимаю. Вам нужен не просто список полей, а полноценный **Manifesto & Technical Specification** — документ, который объясняет философию перехода от «простого чат-бота» к «игровому движку на базе LLM».

Ниже представлен проект спецификации **Nexus World Standard (NWS)**. Этот документ структурирован так, чтобы его можно было представить сообществу или использовать как внутренний стандарт разработки.

---

# Nexus World Standard (NWS) v1.0: Спецификация универсальных модулей виртуальных миров

## 1. Введение и Мотивация

### 1.1. Кризис персонаже-центричности

Существующие стандарты (Character Card V2/V3) создавались в эпоху «одиночных чат-ботов». Их коренная проблема — **субъективность**. Все данные привязаны к личности одного персонажа (`{{char}}`). Это делает невозможным создание сложных ролевых систем, где мир первичен, а персонажи — лишь его часть.

### 1.2. Проблема логического разрыва сценариев

В текущих форматах поле `scenario` является глобальным. Создатели контента вынуждены идти на «грязные хаки»:

- Прятать инструкции сценария внутри приветствия, чтобы пользователь не видел спойлеров.
- Использовать макросы для подмены контекста, что часто ломает логику при переключении между альтернативными приветствиями.

**NWS решает это через атомарность:** сценарий, локация и активные NPC жестко привязываются к конкретной точке входа (приветствию).

---

## 2. Ключевые Проблемы и Пути их Решения

| Проблема в V3                                                    | Решение в NWS                                                                      | Обоснование |
| ---------------------------------------------------------------- | ---------------------------------------------------------------------------------- | ----------- |
| **Глобальный сценарий.** Одно описание мира на все случаи жизни. | **Scenario-per-Greeting.** Каждое приветствие несет свой уникальный слой сценария. |

| Позволяет в одной «карточке» хранить 10 разных приключений (от тюрьмы до королевского бала). |
| **Отсутствие приватности.** Игрок видит сценарий в настройках. | **Hidden Context Layer.** Специальные поля `secret_info`, доступные только ИИ.

| Создает интригу. ИИ знает, что NPC — предатель, а игрок — нет. |
| **Слабая навигация.** Локации описаны текстом в Lorebook. | **Spatial Graph Nodes.** Локации — это объекты со связями (`adjacency`).

| Позволяет приложению строить карту и автоматически менять фоны/ассеты.

|
| **NPC-хаос.** NPC — это просто записи в Lorebook без глубокой личности. | **Entity Component System (ECS).** Реестр NPC с полноценными карточками внутри модуля.

| ИИ может управлять 20+ персонажами без потери их индивидуального стиля речи.

|

---

## 3. Архитектурная модель: Модуль как Мир

В NWS корневым объектом является **World Manifest**. Модуль больше не называется «карточкой персонажа», это «игровой модуль».

### 3.1. Иерархия данных

1. **Metadata:** Описание самого модуля (версия, автор, теги).
2. **Entity Registry:** База всех «актеров» (люди, монстры, боги).
3. **Location Registry:** Граф помещений и регионов.
4. **Entry Points (Greeting Bundles):** Список стартовых ситуаций.
5. **Global Logic:** Правила мира (магия, экономика, статы).

---

## 4. Спецификация Схем Данных (JSON Schema)

### 4.1. Корневой объект (Manifest)

```json
{
  "nws_version": "1.0.0",
  "metadata": {
    "uuid": "7b2e...",
    "title": "Хроники Аркадии",
    "description": "Мрачное технофэнтези",
    "assets_path": "embeded://assets/"
  },
  "world_state": {
    "current_time": "12:00",
    "global_modifiers": ["magic_is_low"]
  },
  "registries": {
    "entities": "./entities.json", // Ссылки на внутренние файлы в CHARX-архиве
    "locations": "./locations.json"
  }
}
```

### 4.2. Контекстная точка входа (Greeting Bundle)

Этот объект полностью заменяет старый массив `alternate_greetings`.

```json
{
  "id": "start_001",
  "name": "Пленник подземелья", // То, что видит юзер в меню
  "public_message": "Вы просыпаетесь на холодном полу. В темноте гремят цепи...",
  "execution_layer": {
    "scenario_override": "Игрок заперт в темнице. Его задача — выбраться.",
    "secret_info": "В стене за бочкой есть потайной ход, NPC Эрик поможет его найти.",
    "active_location_id": "loc_cell_01",
    "spawn_entities": ["npc_eric_guard"],
    "inject_lore": ["dungeon_history", "lockpicking_rules"]
  }
}
```

### 4.3. Узел локации (Spatial Node)

Локация определяет визуальный и звуковой контекст.

```json
{
  "id": "loc_cell_01",
  "name": "Грязная камера",
  "description": "Каменные стены, покрытые плесенью. Маленькое окно с решеткой.",
  "adjacency": ["loc_corridor_01"], // Куда можно перейти
  "zone_rules": "Магия здесь блокируется рунами на стенах.",
  "assets": {
    "background": "embeded://images/jail.png",
    "ambient_audio": "embeded://audio/drips.mp3"
  }
}
```

---

## 5. Протокол обработки данных (Application Logic)

### 5.1. Динамическая сборка промпта (Just-In-Time Context)

Приложение не должно подавать весь модуль в ИИ сразу. Оно обязано фильтровать контекст:

1. **System Prompt:** Базовые правила NWS + Метаданные мира.
2. **Current Location:** Описание только текущего узла `active_location_id`.
3. **Visible Entities:** Данные NPC, находящихся в этой же локации.
4. **Greeting Scenario:** Прикладной сценарий из выбранного `Entry Point`.

### 5.2. Управление «Секретным слоем»

Поле `secret_info` подается ИИ в блоке инструкций ``. Приложение обязано гарантировать, что этот текст не отображается в UI игрока, даже если он откроет настройки карточки в режиме просмотра.

---

## 6. Расширение CHARX: Модульный Архив

Вместо плоской структуры CHARX, NWS требует иерархии:

- `assets/images/` — визуальный ряд мира.
- `assets/audio/` — фоновые звуки для локаций.
- `logic/` — файлы сценариев (например, `.ink` для жестко заданных квестов).

- `data/` — JSON-файлы реестров (entities, locations).

---

## 7. Заключение

**Nexus World Standard** превращает ролевой опыт из «переписки с ботом» в полноценное приключение. Переход к этой спецификации позволяет:

1. **Создателям:** Делать глубокие квесты с сюрпризами.
2. **Игрокам:** Исследовать живые миры, а не просто перебирать персонажей.
3. **Разработчикам:** Строить UI, который понимает географию мира и автоматически обновляет ассеты.

---

### Почему это хорошо для вас:

- **Масштабируемость:** Вы можете начать с одного персонажа, но легко расширить карточку до целой империи.
- **Чистота приветствий:** Игрок просто выбирает «Начать как вор» или «Начать как маг», и приложение само под капотом меняет сценарий, локацию и набор NPC.
- **Изоляция данных:** Использование UUID для персонажей исключает путаницу «кто есть кто», даже если в мире два NPC с именем «Стражник».

Вы можете скопировать этот документ как основу для вашей Wiki или технического задания.

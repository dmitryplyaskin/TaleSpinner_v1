# TaleSpinner World Module Spec (WMS) — Core v0.1

Документ фиксирует **минимальную жизнеспособную спецификацию** “миро-центричной карточки” для TaleSpinner.

Статус: **концепт / рабочий черновик**.

- Пока мы **не реализуем** формат, этот документ описывает “что нам нужно” и может свободно меняться **внутри v0.1** (переименования полей, перестановки секций, уточнения структуры).
- Когда начнём реализацию, мы “заморозим” v0.1 как контракт и дальше будем версионировать изменения.

Цель: дать формат, который:

- масштабируется от “один персонаж” до “мир + NPC + локации + ассеты”;
- поддерживает **несколько стартов** (приветствий) с **собственным сценарием на каждый старт** (_scenario-per-greeting_);
- удобно импортируется/экспортируется как единый модуль;
- не смешивает “контент” и “текущее состояние” (runtime).

---

## 1) Нотация и термины

- **Module**: пакет контента (JSON + ассеты), который можно импортировать в TaleSpinner.
- **Entry point**: точка входа/старт (выбор игрока в UI), содержит **greeting** и **scenario** для этого старта.
- **Entity**: сущность мира. Это базовый “класс” с общими полями + **подтип по `type`** (персонаж, предмет, локация, фракция и т.д.). Любой `type` может иметь собственные поля/правила.
- **Asset**: файл внутри модуля (изображение/аудио/прочее), на который ссылаются поля JSON.

---

## 2) Границы спецификации (очень важно)

### 2.1 Что входит в Core v0.1

- **Манифест** (`module.json`) с метаданными и ссылками на реестры.
- **Реестры** (минимум): `entities`, `entryPoints`.
- **Сценарии**: может существовать **глобальный сценарий** модуля и/или **сценарий конкретного старта** (_scenario-per-entry-point_).
- **Ссылки на ассеты** (URI внутри модуля).
- **Правила идентификаторов и ссылок** (ID, ссылки между сущностями/локациями/ассетами).

### 2.2 Чего в Core v0.1 нет (non-goals)

В этом релизе **осознанно отсутствуют**:

- скрипты/движки ветвления (любой внешний скриптинг/DSL).
- встроенная система RNG/кубов/статов как “движок правил”.
- RAG/векторные индексы внутри спецификации.
- формальные правила “как именно собирать промпт/системную инструкцию” (это ответственность prompt templates/pipelines и выбирается пользователем).

---

## 3) Принципы дизайна

- **Контент отдельно от runtime**: модуль хранит _описания_ и _дефолты_, но не хранит “текущее” состояние игры/чата.
- **Двухслойный сценарий**:
  - **`globalScenario`** (опционально) — общий фон/конфликт/установка мира;
  - **`scenario` в entry point** (опционально) — конкретная ситуация старта, которая уточняет/дополняет глобальный фон.
- **Спека описывает данные, а не поведение**: наличие полей не означает, что приложение обязано их использовать. То, как именно `globalScenario`/`entryPoint.scenario` попадут в системную инструкцию, определяется **темплейтом**, который настроит пользователь (или может быть полностью пропущено).
- **Ссылочность через IDs**: связи делаются по ID, не по именам.
- **Модульность**: можно загрузить только нужные части (реестры и ассеты).

---

## 4) Runtime vs Module (разделение ответственности)

### 4.1 Module (то, что в архиве)

- описания сущностей;
- список entry points (стартов);
- дефолтные значения (например, стартовая локация для entry point).

### 4.2 Runtime (то, что хранится в БД TaleSpinner)

Runtime принадлежит конкретному чату/ветке и **не является частью модуля**:

- выбранный entry point;
- текущая локация;
- какие entities “активны в сцене”;
- любые “флаги”, прогресс, инвентарь, отношения, здоровье и т.п.

Модуль может задавать **начальные значения** (seed) для runtime на старте, но дальнейшее состояние — ответственность приложения.

---

## 5) Формат упаковки (container)

Core v0.1 предполагает модуль как папку или zip-архив со стабильной структурой.

Правило хранения данных в `data/`: **один JSON-файл на один объект**:

- один файл на одну entity;
- один файл на один entry point.

### 5.1 Структура модуля

```
module/
  module.json
  data/
    entities/
      <entity-type>/
        <entity-id>.json
        ...
    entry-points/
      <entry-point-id>.json
  assets/
    images/
    audio/
    other/
```

### 5.2 URI для ссылок на ассеты

Используем единый префикс:

- `asset:/assets/...`

Примеры:

- `asset:/assets/images/tavern.avif`
- `asset:/assets/audio/tavern.ogg`

Требование: путь должен резолвиться **внутри модуля**, без внешних URL в Core v0.1.

---

## 6) Идентификаторы и ссылки

- `id`: строка.
- Рекомендуемый формат: UUID (но в Core v0.1 не обязателен).
- ID **уникален в рамках реестра** (`entities`, `entryPoints`).
- Ссылки всегда по ID:
  - `entryPoint.initial.locationId` → `entities[id]` (где `entities.type = "location"`)
  - `entryPoint.initial.activeEntityIds[]` → `entities[id]`
  - `entity(type="location").adjacentLocationIds[]` → `entities[id]` (где `entities.type = "location"`)

---

## 7) Данные: корневой манифест

Файл: `module.json`

### 7.1 Назначение

- идентифицирует модуль и его версию;
- указывает пути до реестров;
- задаёт дефолтный entry point (опционально).
- может содержать общий “фон” (глобальный сценарий) для всего модуля.

### 7.2 Минимальная форма (пример)

```json
{
  "spec": "talespinner_wms",
  "specVersion": "0.1",
  "meta": {
    "id": "b4c2f2d5-6c86-4b4d-9c7d-54c0b1b0e2ad",
    "title": "Забытый Элизиум",
    "author": "Explorer_01",
    "moduleVersion": "0.1.0",
    "description": "Модуль-демо: стартовые сцены и базовые локации."
  },
  "globalScenario": "Идет борьба между двумя наследниками престола.",
  "registries": {
    "entities": "data/entities/",
    "entryPoints": "data/entry-points/"
  },
  "defaults": {
    "entryPointId": "start-forest-001"
  }
}
```

---

## 8) Entry points (scenario-per-greeting)

Файл: `data/entry-points/*.json`

### 8.1 Назначение

Entry point — это _атомарный старт_, который определяет:

- что показать пользователю в списке стартов;
- какое “первое сообщение” (greeting) применить;
- какой “сценарий старта” доступен **для выбранного старта** (как отдельное поле данных; способ использования определяется темплейтом);
- какие начальные runtime-значения выставить.

### 8.2 Модель (описание полей)

- `id` (string): идентификатор entry point.
- `label` (string): короткое имя для UI (“Встреча в лесу”).
- `greeting` (string): первый видимый текст/сообщение, которое попадёт в чат при старте (как “первое сообщение/приветствие”).
- `scenario` (string, optional): контекст/ситуация **только для этого старта** (дополняет `globalScenario`, если он задан).
- `initial` (object):
  - `locationId` (string): стартовая локация.
  - `activeEntityIds` (string[]): список сущностей, которые считаются активными в стартовой сцене.
  - `loreEntityIds` (string[], optional): список entities с `type: "lore"` (или иным “knowledge” типом), которые **явно доступны** для темплейта на старте (темплейт может использовать или игнорировать).
  - `tags` (string[], optional): теги для UI/фильтрации.

### 8.3 Пример

```json
[
  {
    "id": "start-forest-001",
    "label": "Встреча в лесу",
    "greeting": "Странник в плаще преграждает вам путь: «Стой, путник. Дальше дороги нет.»",
    "scenario": "Тебя посадили в клетку, потому что поймали на шпионаже в пользу второго наследника.",
    "initial": {
      "locationId": "loc-forest-gate",
      "activeEntityIds": ["npc-guard-01"]
    }
  }
]
```

---

## 9) Entities (реестр сущностей)

Файл: `data/entities/<type>/*.json`

### 9.1 Назначение

Сущность описывает “кто/что это” и содержит текстовые поля, которые TaleSpinner сможет использовать при сборке контекста.

### 9.2 Модель (описание полей)

Entity в Core v0.1 — это “база + подтип по `type`”.

**Общие поля (`EntityBase`)**:

- `id` (string)
- `type` (string): например `character`, `npc`, `item`, `location`, `faction`, `note` (перечень не фиксируем жёстко, но ожидаем согласованный набор типов в UI/валидаторе).
- `name` (string)
- `summary` (string, optional): краткое описание для UI/быстрой вставки.
- `description` (string, optional): развёрнутое описание.
- `assets` (object, optional):
  - `avatar` (string, optional): `asset:/...`
  - `images` (string[], optional): `asset:/...`
- `tags` (string[], optional)

**Поля подтипов (примеры, пока концепт)**:

- Для `type: "npc" | "character"`:
  - `voice` (string, optional): стиль речи/манера общения.
- Для `type: "location"`:
  - `adjacentLocationIds` (string[], optional): соседние локации (ID других entities с `type: "location"`).
  - `assets.background` (string, optional): `asset:/...`
  - `assets.ambientAudio` (string, optional): `asset:/...`
- Для `type: "lore"`:
  - `content` (string): основной текст записи лора.
  - `aliases` (string[], optional): альтернативные названия/термины.
  - `links` (object, optional):
    - `relatedEntityIds` (string[], optional): ссылки на связанные entities (любой `type`).
  - `match` (object, optional): данные для поиска/ранжирования (если реализация захочет)
    - `keywords` (string[], optional)
    - `phrases` (string[], optional)
    - `weight` (number, optional)

### 9.3 Пример

```json
[
  {
    "id": "npc-guard-01",
    "type": "npc",
    "name": "Эрик",
    "summary": "Подозрительный страж на границе леса.",
    "description": "Гордый, изнурённый, держится уверенно, но заметно устал.",
    "voice": "Короткие фразы, хриплый голос, иногда кашляет.",
    "assets": {
      "avatar": "asset:/assets/images/erik.png"
    },
    "tags": ["guard", "forest"]
  },
  {
    "id": "loc-forest-gate",
    "type": "location",
    "name": "Врата Запретного Леса",
    "description": "Старые камни, туман, влажная земля под ногами.",
    "adjacentLocationIds": ["loc-road-01", "loc-forest-01"],
    "assets": {
      "background": "asset:/assets/images/forest_gate.avif",
      "ambientAudio": "asset:/assets/audio/forest_gate.ogg"
    },
    "tags": ["forest"]
  },
  {
    "id": "lore-succession-conflict",
    "type": "lore",
    "name": "Конфликт наследников престола",
    "summary": "Два наследника борются за трон после болезни монарха.",
    "content": "Идет борьба между двумя наследниками престола. Двор расколот, в столице усилились шпионы и провокации. Любой намёк на поддержку одной из сторон может стоить свободы или жизни.",
    "aliases": [
      "борьба наследников",
      "наследники престола",
      "дворцовый раскол"
    ],
    "links": {
      "relatedEntityIds": ["faction-heir-1", "faction-heir-2", "loc-capital"]
    },
    "match": {
      "keywords": ["наследник", "престол", "двор", "шпион", "заговор", "трон"],
      "weight": 0.8
    },
    "tags": ["politics", "capital"]
  }
]
```

---

### 9.4 Пример файла (как хранится в модуле)

Файл: `data/entities/lore/lore-succession-conflict.json`

```json
{
  "id": "lore-succession-conflict",
  "type": "lore",
  "name": "Конфликт наследников престола",
  "summary": "Два наследника борются за трон после болезни монарха.",
  "content": "Идет борьба между двумя наследниками престола. Двор расколот, в столице усилились шпионы и провокации. Любой намёк на поддержку одной из сторон может стоить свободы или жизни.",
  "aliases": ["борьба наследников", "наследники престола", "дворцовый раскол"],
  "links": {
    "relatedEntityIds": ["faction-heir-1", "faction-heir-2", "loc-capital"]
  },
  "match": {
    "keywords": ["наследник", "престол", "двор", "шпион", "заговор", "трон"],
    "weight": 0.8
  },
  "tags": ["politics", "capital"]
}
```

## 10) Как это будет работать в TaleSpinner (высокоуровневый протокол)

### 10.1 Импорт

- пользователь импортирует модуль (папку/архив);
- приложение валидирует наличие `module.json` и указанных реестров;
- создаётся `EntityProfile` (или другая доменная сущность) с сохранением исходного JSON модуля.

### 10.2 Старт чата

- UI показывает `entryPoints` как список “стартов”;
- пользователь выбирает entry point;
- runtime (в БД чата/ветки) инициализируется из `entryPoint.initial`:
  - `currentLocationId = locationId`
  - `activeEntityIds = [...]`
- в чат добавляется `greeting` (как стартовое сообщение/контент);
- `globalScenario` и `entryPoint.scenario` доступны для формирования системной инструкции, но **как именно** они используются (или игнорируются) — решает выбранный пользователем prompt template.

### 10.3 Дальнейший ход

Дальше приложение может менять runtime (текущую локацию/активные сущности) без изменения модуля.

---

## 11) Совместимость / миграции (в общих чертах)

Core v0.1 допускает наличие конвертеров:

- **CCV2/CCV3 → WMS**: импорт “персонажной карточки” как модуля, где:
  - `entities` содержит одного персонажа;
  - `entryPoints` создаётся из `first_mes` и `alternate_greetings` (каждый greeting становится entry point; `scenario` может быть пустым или сформированным по правилам импорта);
  - ассеты (аватар) маппятся в `assets`.

Это **не требование Core**, а рекомендация для импорта.

---

## 12) Roadmap после v0.1 (не часть Core)

Потенциальные расширения (если понадобится в проекте):

- Lore/knowledge registry (ссылочные статьи/заметки мира)
- Явные “relationship/state” слои, но строго как _seed_ или _runtime extension_
- Внешние URL-ассеты (с политиками безопасности)
- Декларативные “scene bundles” для смены контекста внутри одной ветки

---

## 13) Открытые решения (внутри v0.1, пока концепт)

Это список вопросов, которые **нужно закрыть до реализации**, но сейчас мы сознательно держим их как варианты.

### 13.1 Нейминг и стиль ключей

Сейчас документ использует `camelCase`. Если решим иначе (например, `snake_case`), лучше зафиксировать это до JSON Schema.

### 13.2 Ссылки на ассеты

Сейчас в Core v0.1 описано: только `asset:/...` и только внутрь модуля.

Возможные расширения:

- внешние URL (с политиками безопасности/скачиванием/кешем)
- относительные пути без `asset:/` (и правило резолвинга)

const ruOperationProfiles = {
			sidebar: {
				title: 'Операции',
			},
			tabs: {
				profiles: 'Профили',
				blocks: 'Блоки',
			},
			defaults: {
				newProfile: 'Новый профиль',
				copyName: '{{name}} (копия)',
				untitledOperation: 'Операция без названия',
			},
			blocks: {
				defaults: {
					newBlock: 'Новый блок',
				},
				blockSettingsTitle: 'Настройки блока',
				blockName: 'Название блока',
				blockEnabled: 'Блок включен',
				selectBlock: 'Выберите блок',
				emptySelectBlock: 'Выберите блок для редактирования операций.',
				profileCompositionTitle: 'Состав профиля',
				addBlock: 'Добавить блок',
				emptyComposition: 'В профиль пока не добавлены блоки.',
				blockRefEnabled: 'Включен в этом профиле',
				blockOrder: 'Порядок',
				actions: {
					createBlock: 'Создать блок',
					duplicateBlock: 'Дублировать блок',
					editBlock: 'Редактировать блок',
					deleteBlock: 'Удалить блок',
					exportBlock: 'Экспортировать блок',
					importBlocks: 'Импортировать блоки',
				},
			},
			actions: {
				openNodeEditor: 'Открыть Node Editor',
				discard: 'Отменить изменения',
				resetSessionId: 'Сбросить session id',
				createProfile: 'Создать профиль',
				duplicateProfile: 'Дублировать профиль',
				deleteProfile: 'Удалить профиль',
				exportProfile: 'Экспортировать профиль',
				importProfiles: 'Импортировать профили',
				addOperation: 'Добавить операцию',
				deleteOperation: 'Удалить операцию',
				group: 'Группировать',
				ungroup: 'Разгруппировать',
			},
			empty: {
				selectProfile: 'Выберите профиль для редактирования операций.',
			},
			profilePicker: {
				noneSelected: 'Профиль не выбран',
				select: 'Выберите профиль',
				current: 'Текущий профиль',
			},
			operations: {
				title: 'Операции',
				visibleOfTotal: '{{visible}} показано из {{total}}',
				empty: 'Операций пока нет. Добавьте первую, чтобы начать редактирование.',
			},
			inspector: {
				title: 'Инспектор операции',
				noneSelected: 'Операция не выбрана',
				operationNumber: 'Операция #{{number}}',
				selectFromList: 'Выберите операцию из списка для редактирования.',
			},
			profileSettings: {
				title: 'Настройки профиля',
				profileName: 'Имя профиля',
				profileEnabled: 'Профиль включен',
				executionMode: 'Режим выполнения',
				sessionId: 'Session id профиля операций',
				sessionIdInfo: 'Сбросьте этот id, если нужен новый scope валидации и группировки изменений.',
				invalidJson: 'Некорректный JSON',
			},
			operationEditor: {
				title: 'Операция',
				unsaved: 'Не сохранено',
			},
			fields: {
				operationName: 'Имя операции',
				kind: 'Тип',
				kindDescription: 'Определяет секцию специфичных параметров ниже.',
				opId: 'opId: {{value}}',
			},
			sections: {
				basics: 'Базовые',
				kindSpecific: 'Параметры типа',
				execution: 'Выполнение',
				effectsOutput: 'Эффекты / Выход',
				advanced: 'Расширенные',
			},
			sectionsLabels: {
				description: 'Описание',
				enabled: 'Включено',
				required: 'Обязательная',
				hook: 'Hook',
				triggers: 'Триггеры',
				order: 'Порядок',
				dependsOn: 'Зависит от',
				effectType: 'Тип эффекта',
				artifactTag: 'Тег артефакта',
				persistence: 'Persistence',
				usage: 'Usage',
				semantics: 'Semantics',
				promptTimeEffect: 'Эффект prompt-time',
				mode: 'Режим',
				sourceOptional: 'Источник (опционально)',
				role: 'Роль',
				depthFromEnd: 'atDepth',
				target: 'Цель',
			},
			tooltips: {
				description: 'Короткое описание, отображаемое в списке, лейблах узлов и документации профиля.',
				enabled: 'Отключенные операции пропускаются и не коммитят эффекты.',
				required: 'Обязательные операции должны завершиться со статусом done. Иначе запуск соответствующего hook завершится ошибкой.',
				hook: 'Выберите, запускается ли операция до или после основного вызова LLM.',
				triggers: 'generate запускается на новом ходе; regenerate — при новой assistant-вариации.',
				order: 'Порядок коммита детерминирован: сначала зависимости, затем меньший order, затем opId.',
				dependsOn: 'Операция ждёт завершения всех зависимостей со статусом done. Неудачная или пропущенная зависимость блокирует старт.',
				effectType: 'Выберите, как применить отрендеренный результат при commit во время выполнения.',
				artifactTag: 'Используйте тег без префикса art. У каждого тега в профиле должен быть один writer.',
				persistence: 'persisted переживает ходы; run_only существует только в текущем запуске.',
				usage: 'Выберите, используется ли артефакт в prompt, UI, обоих, или только внутренне.',
				semantics: 'Семантическая метка для потребителей, например "state" или "log/feed".',
				promptTimeEffect: 'Тип эффекта для prompt-time вставки текста.',
				mode: 'prepend => payload + system; append => system + payload; replace => system = payload.',
				sourceOptional: 'Необязательная метка источника для отладки/объяснимости.',
				role: 'Роль для синтетического prompt-сообщения.',
				depthFromEnd:
					'0 — вставить в конец; N — вставить на глубине N от конца. Большие значения ограничиваются позицией сразу после основной system-инструкции.',
				target: 'before_main_llm допускает только target=user; after_main_llm допускает user или assistant.',
			},
			outputType: {
				artifacts: 'Artifacts',
				promptTime: 'Prompt-time effects',
				turnCanonicalization: 'Turn canonicalization effects',
			},
			outputNotes: {
				promptTimePayloadSource: 'Источник payload эффекта — текст, отрендеренный шаблоном.',
				turnCanonicalization: 'Текущий режим replace_text: выбранная часть хода перезаписывается template output.',
			},
			promptTimeKind: {
				appendAfterLastUser: 'prompt.append_after_last_user',
				systemUpdate: 'prompt.system_update',
				insertAtDepth: 'prompt.insert_at_depth',
			},
			kind: {
				template: 'Template',
				llm: 'LLM',
				rag: 'RAG',
				tool: 'Tool',
				compute: 'Compute',
				transform: 'Transform',
				legacy: 'Legacy',
			},
			kindSection: {
				jsonParamsLabel: '{{kindLabel}} params (JSON)',
				jsonParamsInfo: 'Параметры типа сохраняются как JSON-объект в config.params.params.',
				template: {
					description: 'Template-операции рендерят текст из доступных переменных и передают результат в output effects.',
					strictVariables: 'Строгие переменные',
					strictVariablesInfo: 'Если включено, шаблон может использовать только объявленные переменные.',
					templateText: 'Текст шаблона',
					templateTextInfo: 'Тело шаблона операции.',
				},
				compute: {
					description: 'Настройте детерминированные вычисления или преобразования над структурированными входами.',
				},
				legacy: {
					description: 'Используйте секцию для compatibility-payload, необходимых legacy-исполнителям.',
				},
				llm: {
					description: 'Настройте параметры прямого вызова модели для этой операции.',
					blocks: {
						prompt: 'Промпт',
						provider: 'Провайдер',
						samplers: 'Сэмплеры',
						reliability: 'Надежность',
					},
					strictVariables: 'Строгие переменные',
					strictVariablesInfo: 'Если включено, Liquid-шаблоны падают при неизвестных переменных.',
					system: 'System prompt',
					systemInfo: 'Опциональный шаблон системного сообщения для этой операции.',
					prompt: 'User prompt',
					promptInfo: 'Обязательный шаблон запроса, рендерится в контексте операции.',
					samplerPreset: 'Пресет сэмплеров',
					samplerPresetInfo: 'При выборе пресета его значения копируются в поля overrides.',
					outputMode: 'Режим результата',
					outputModeInfo: '`text` сохраняет сырой ответ модели, `json` требует строгий JSON parse.',
					outputModeText: 'Текст',
					outputModeJson: 'Строгий JSON',
					jsonParseMode: 'Режим парсинга JSON',
					jsonParseModeInfo: 'Как извлекать JSON payload из ответа модели перед парсингом.',
					jsonParseModeHintRaw: 'Парсить весь ответ целиком как JSON без извлечения.',
					jsonParseModeHintMarkdownCodeBlock: 'Извлечь содержимое из первого fenced code block (```json ... ```).',
					jsonParseModeHintCustomRegex: 'Применить кастомный regex к ответу; при наличии берётся первая capture group.',
					jsonParseModeRaw: 'Сырой ответ',
					jsonParseModeMarkdownCodeBlock: 'Из markdown code block',
					jsonParseModeCustomRegex: 'Кастомный regex',
					jsonCustomPattern: 'Шаблон regex',
					jsonCustomPatternInfo: 'Используется JS regex. Если есть capture group, берется первая.',
					jsonCustomFlags: 'Флаги regex',
					jsonCustomFlagsInfo: 'Флаги JS regex, например `i` или `gm`.',
					timeoutMs: 'Таймаут (мс)',
					timeoutMsInfo: 'Таймаут одного запроса к провайдеру.',
					retryMaxAttempts: 'Макс. попыток',
					retryMaxAttemptsInfo: 'Общее число попыток, включая первую.',
					retryBackoffMs: 'Пауза между повторами (мс)',
					retryBackoffMsInfo: 'Задержка между повторными попытками.',
					strictSchemaValidation: 'Строгая валидация схемы',
					strictSchemaValidationInfo: 'Проверять распарсенный JSON-ответ по схеме через zod.',
					jsonSchema: 'JSON-схема (typed format)',
					jsonSchemaInfo: 'Используйте JSON-объект с type-descriptor полями, optional-ключами, массивами и вложенными объектами.',
					retryOn: {
						label: 'Повторять при',
						timeout: 'Таймаут',
						providerError: 'Ошибка провайдера',
						rateLimit: 'Rate limit',
					},
					retryOnInfo: 'Классы ошибок, при которых разрешен повтор.',
					schemaHelp: {
						open: 'Как писать схему',
						title: 'Формат JSON-схемы',
						description: 'Схема задаётся в упрощенном typed JSON формате и компилируется в zod.',
						ruleTypeDescriptor: 'Используйте строки вида "type: описание" (string, number, boolean, null, integer).',
						ruleOptional: 'Добавьте "?" в конце ключа, чтобы сделать поле необязательным.',
						ruleArray: 'Для массива передайте пример с одним элементом-схемой, например ["string: тег"] или [{...}].',
						ruleLiterals: 'Числа/boolean/null без descriptor автоматически трактуются как соответствующие примитивные типы.',
					},
				},
				rag: {
					description: 'Настройте источник retrieval и параметры ранжирования для сборки контекста.',
				},
				tool: {
					description: 'Определите имя tool-вызова, аргументы и runtime-лимиты.',
				},
				transform: {
					description: 'Опишите шаги постобработки для выходов операции.',
				},
			},
			filters: {
				allKinds: 'Все типы',
				searchPlaceholder: 'Поиск по имени, id или типу',
				searchAria: 'Поиск операций',
				byKindAria: 'Фильтр по типу операции',
				allStates: 'Все состояния',
				enabledOnly: 'Только включенные',
				disabledOnly: 'Только выключенные',
				byEnabledAria: 'Фильтр по enabled',
				allRequiredStates: 'Все required-состояния',
				requiredOnly: 'Только required',
				optionalOnly: 'Только optional',
				byRequiredAria: 'Фильтр по required',
				noMatches: 'Нет операций, подходящих под текущие фильтры.',
			},
			nodeEditor: {
				title: 'Node Editor',
				subtitle: 'Узлы представляют операции. Ребра — dependsOn связи. Выберите узел для редактирования деталей.',
				hideOperation: 'Скрыть операцию',
				showOperation: 'Показать операцию',
				autoLayout: 'Авто-лейаут',
				jsonError: 'Ошибка JSON',
				graphTab: 'Граф',
				inspectorTab: 'Инспектор',
				groupsPlaceholder: 'Группы',
				selectNode: 'Выберите узел для редактирования деталей операции.',
				groupNamePrompt: 'Имя группы',
				groupNameDefault: 'Группа {{index}}',
			},
			groupEditor: {
				title: 'Редактировать группу',
				name: 'Имя',
				namePlaceholder: 'Имя группы',
				background: 'Фон',
				backgroundPlaceholder: 'CSS цвет (альфа будет проигнорирована)',
				backgroundHint: 'Прозрачность фиксирована под дефолтные группы; вы управляете только базовым цветом.',
				delete: 'Удалить группу',
			},
			placeholders: {
				none: 'Нет',
			},
			confirm: {
				deleteProfile: 'Удалить этот профиль операций?',
				deleteBlock: 'Удалить этот блок операций?',
				deleteOperation: 'Удалить выбранную операцию?',
				deleteGroup: 'Удалить эту группу?',
				deleteSelectedOperations: 'Удалить выбранные операции?',
				ungroupSelected: 'Разгруппировать выбранный набор?',
			},
			toasts: {
				created: 'Профиль операций создан',
				createError: 'Не удалось создать профиль операций',
				saved: 'Профиль операций сохранен',
				saveError: 'Не удалось сохранить профиль операций',
				deleted: 'Профиль операций удален',
				deleteError: 'Не удалось удалить профиль операций',
				importTitle: 'Импорт профиля операций',
				importedCount: 'Импортировано: {{count}}',
				importError: 'Не удалось импортировать профили операций',
				exportError: 'Ошибка экспорта',
			},
		};

export default ruOperationProfiles;


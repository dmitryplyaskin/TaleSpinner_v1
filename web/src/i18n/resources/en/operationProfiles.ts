const enOperationProfiles = {
			sidebar: {
				title: 'Operations',
			},
			tabs: {
				profiles: 'Profiles',
				blocks: 'Blocks',
			},
			defaults: {
				newProfile: 'New profile',
				copyName: '{{name}} (copy)',
				untitledOperation: 'Untitled operation',
			},
			blocks: {
				defaults: {
					newBlock: 'New block',
				},
				blockSettingsTitle: 'Block settings',
				blockName: 'Block name',
				blockEnabled: 'Block enabled',
				selectBlock: 'Select block',
				emptySelectBlock: 'Select a block to edit operations.',
				profileCompositionTitle: 'Profile composition',
				addBlock: 'Add block',
				emptyComposition: 'No blocks attached to this profile yet.',
				blockRefEnabled: 'Enabled in this profile',
				blockOrder: 'Order',
				actions: {
					createBlock: 'Create block',
					duplicateBlock: 'Duplicate block',
					editBlock: 'Edit block',
					deleteBlock: 'Delete block',
					exportBlock: 'Export block',
					importBlocks: 'Import blocks',
				},
			},
			actions: {
				openNodeEditor: 'Open Node Editor',
				discard: 'Discard changes',
				resetSessionId: 'Reset session id',
				createProfile: 'Create profile',
				duplicateProfile: 'Duplicate profile',
				deleteProfile: 'Delete profile',
				exportProfile: 'Export profile',
				importProfiles: 'Import profiles',
				addOperation: 'Add operation',
				deleteOperation: 'Delete operation',
				group: 'Group',
				ungroup: 'Ungroup',
			},
			empty: {
				selectProfile: 'Select a profile to edit operations.',
			},
			profilePicker: {
				noneSelected: 'No profile selected',
				select: 'Select profile',
				current: 'Current profile',
			},
			operations: {
				title: 'Operations',
				visibleOfTotal: '{{visible}} shown of {{total}}',
				empty: 'No operations yet. Add one to start editing.',
			},
			inspector: {
				title: 'Operation inspector',
				noneSelected: 'No operation selected',
				operationNumber: 'Operation #{{number}}',
				selectFromList: 'Select an operation from the list to edit.',
			},
			profileSettings: {
				title: 'Profile settings',
				profileName: 'Profile name',
				profileEnabled: 'Profile enabled',
				executionMode: 'Execution mode',
				sessionId: 'Operation profile session id',
				sessionIdInfo: 'Reset this id if you need a new validation scope and change-grouping scope.',
				invalidJson: 'Invalid JSON',
			},
			operationEditor: {
				title: 'Operation',
				unsaved: 'Unsaved',
			},
			fields: {
				operationName: 'Operation name',
				kind: 'Kind',
				kindDescription: 'Determines the kind-specific parameters section below.',
				opId: 'opId: {{value}}',
			},
			sections: {
				basics: 'Basics',
				kindSpecific: 'Kind parameters',
				execution: 'Execution',
				effectsOutput: 'Effects / Output',
				advanced: 'Advanced',
			},
			sectionsLabels: {
				description: 'Description',
				enabled: 'Enabled',
				required: 'Required',
				hook: 'Hook',
				triggers: 'Triggers',
				order: 'Order',
				dependsOn: 'Depends on',
				effectType: 'Effect type',
				artifactTag: 'Artifact tag',
				persistence: 'Persistence',
				usage: 'Usage',
				semantics: 'Semantics',
				promptTimeEffect: 'Prompt-time effect',
				mode: 'Mode',
				sourceOptional: 'Source (optional)',
				role: 'Role',
				depthFromEnd: 'atDepth',
				target: 'Target',
			},
			tooltips: {
				description: 'Short description displayed in operation list, node labels, and profile docs.',
				enabled: 'Disabled operations are skipped and do not commit effects.',
				required: 'Required operations must finish with done status. Otherwise, running the corresponding hook fails.',
				hook: 'Choose whether the operation runs before or after the main LLM call.',
				triggers: '`generate` runs on a new turn; `regenerate` runs on a new assistant variant.',
				order: 'Commit order is deterministic: dependencies first, then lower order, then opId.',
				dependsOn: 'Operation waits for all dependencies with done status. Failed or skipped dependency blocks start.',
				effectType: 'Choose how rendered result is applied during commit at runtime.',
				artifactTag: 'Use a tag without `art` prefix. Each tag in profile should have a single writer.',
				persistence: '`persisted` survives turns; `run_only` exists only during current run.',
				usage: 'Choose whether artifact is used in prompt, UI, both, or internal only.',
				semantics: 'Semantic label for consumers, e.g. "state" or "log/feed".',
				promptTimeEffect: 'Effect kind for prompt-time text insertion.',
				mode: '`prepend` => payload + system; `append` => system + payload; `replace` => system = payload.',
				sourceOptional: 'Optional source label for debugging/explainability.',
				role: 'Role for synthetic prompt message.',
				depthFromEnd:
					'0 inserts at the end; N inserts N messages from the end. Large values clamp right after the main system instruction.',
				target: '`before_main_llm` allows only target=user; `after_main_llm` allows user or assistant.',
			},
			outputType: {
				artifacts: 'Artifacts',
				promptTime: 'Prompt-time effects',
				turnCanonicalization: 'Turn canonicalization effects',
			},
			outputNotes: {
				promptTimePayloadSource: 'Effect payload source is template-rendered text.',
				turnCanonicalization: 'Current `replace_text` mode: selected turn part is overwritten with template output.',
			},
			promptTimeKind: {
				appendAfterLastUser: 'prompt.append_after_last_user',
				systemUpdate: 'prompt.system_update',
				insertAtDepth: 'prompt.insert_at_depth',
			},
			kind: {
				template: 'Template',
				llm: 'LLM',
				rag: 'RAG',
				tool: 'Tool',
				compute: 'Compute',
				transform: 'Transform',
				legacy: 'Legacy',
			},
			kindSection: {
				jsonParamsLabel: '{{kindLabel}} params (JSON)',
				jsonParamsInfo: 'Kind parameters are stored as JSON object in config.params.params.',
				template: {
					description: 'Template operations render text from available variables and pass result to output effects.',
					strictVariables: 'Strict variables',
					strictVariablesInfo: 'When enabled, template can use only declared variables.',
					templateText: 'Template text',
					templateTextInfo: 'Operation template body.',
				},
				compute: {
					description: 'Configure deterministic computations or transformations over structured inputs.',
				},
				legacy: {
					description: 'Use this section for compatibility payload required by legacy executors.',
				},
				llm: {
					description: 'Configure direct model call parameters for this operation.',
					blocks: {
						prompt: 'Prompt',
						provider: 'Provider',
						samplers: 'Samplers',
						reliability: 'Reliability',
					},
					strictVariables: 'Strict variables',
					strictVariablesInfo: 'If enabled, Liquid templates throw when unknown variables are used.',
					system: 'System prompt',
					systemInfo: 'Optional system message template for this operation.',
					prompt: 'User prompt',
					promptInfo: 'Required prompt template rendered against operation context.',
					samplerPreset: 'Sampler preset',
					samplerPresetInfo: 'Selecting a preset copies its values into sampler overrides.',
					outputMode: 'Result mode',
					outputModeInfo: '`text` stores raw model output; `json` requires strict JSON parse.',
					outputModeText: 'Text',
					outputModeJson: 'Strict JSON',
					jsonParseMode: 'JSON parse mode',
					jsonParseModeInfo: 'How to extract JSON payload from model output before parsing.',
					jsonParseModeHintRaw: 'Parse the whole response as JSON without extraction.',
					jsonParseModeHintMarkdownCodeBlock: 'Extract content from the first fenced code block (```json ... ```).',
					jsonParseModeHintCustomRegex: 'Apply custom regex to output; first capture group is used if present.',
					jsonParseModeRaw: 'Raw response',
					jsonParseModeMarkdownCodeBlock: 'From markdown code block',
					jsonParseModeCustomRegex: 'Custom regex',
					jsonCustomPattern: 'Custom regex pattern',
					jsonCustomPatternInfo: 'Use JS regex. First capture group (if present) is used as JSON payload.',
					jsonCustomFlags: 'Custom regex flags',
					jsonCustomFlagsInfo: 'JS regex flags, e.g. `i` or `gm`.',
					timeoutMs: 'Timeout (ms)',
					timeoutMsInfo: 'Per-attempt timeout for the provider request.',
					retryMaxAttempts: 'Retry max attempts',
					retryMaxAttemptsInfo: 'Total attempts including the first call.',
					retryBackoffMs: 'Retry backoff (ms)',
					retryBackoffMsInfo: 'Wait time between retry attempts.',
					strictSchemaValidation: 'Strict schema validation',
					strictSchemaValidationInfo: 'Validate parsed JSON response against schema with zod.',
					jsonSchema: 'JSON schema (typed template)',
					jsonSchemaInfo: 'Use JSON object with type descriptors, optional fields, arrays and nested objects.',
					retryOn: {
						label: 'Retry on',
						timeout: 'Timeout',
						providerError: 'Provider error',
						rateLimit: 'Rate limit',
					},
					retryOnInfo: 'Error classes that are allowed to trigger a retry.',
					schemaHelp: {
						open: 'How to write schema',
						title: 'JSON Schema Format',
						description: 'Schema uses a lightweight typed JSON format and is compiled to zod.',
						ruleTypeDescriptor: 'Use "type: description" for string descriptors (string, number, boolean, null, integer).',
						ruleOptional: 'Append "?" to key name to mark field optional.',
						ruleArray: 'For arrays, pass an example array with one item schema, e.g. ["string: tag"] or [{...}].',
						ruleLiterals: 'Numeric/boolean/null literals infer primitive type automatically.',
					},
				},
				rag: {
					description: 'Configure retrieval source and ranking parameters for context assembly.',
				},
				tool: {
					description: 'Define tool call name, arguments, and runtime limits.',
				},
				transform: {
					description: 'Describe post-processing steps for operation outputs.',
				},
			},
			filters: {
				allKinds: 'All kinds',
				searchPlaceholder: 'Search by name, id, or kind',
				searchAria: 'Search operations',
				byKindAria: 'Filter by operation kind',
				allStates: 'All states',
				enabledOnly: 'Enabled only',
				disabledOnly: 'Disabled only',
				byEnabledAria: 'Filter by enabled',
				allRequiredStates: 'All required states',
				requiredOnly: 'Required only',
				optionalOnly: 'Optional only',
				byRequiredAria: 'Filter by required',
				noMatches: 'No operations match current filters.',
			},
			nodeEditor: {
				title: 'Node Editor',
				subtitle: 'Nodes represent operations. Edges are dependsOn links. Select a node to edit details.',
				hideOperation: 'Hide operation',
				showOperation: 'Show operation',
				autoLayout: 'Auto-layout',
				jsonError: 'JSON error',
				graphTab: 'Graph',
				inspectorTab: 'Inspector',
				groupsPlaceholder: 'Groups',
				selectNode: 'Select a node to edit operation details.',
				groupNamePrompt: 'Group name',
				groupNameDefault: 'Group {{index}}',
			},
			groupEditor: {
				title: 'Edit group',
				name: 'Name',
				namePlaceholder: 'Group name',
				background: 'Background',
				backgroundPlaceholder: 'CSS color (alpha will be ignored)',
				backgroundHint: 'Transparency is fixed for default groups; you control only base color.',
				delete: 'Delete group',
			},
			placeholders: {
				none: 'None',
			},
			confirm: {
				deleteProfile: 'Delete this operations profile?',
				deleteBlock: 'Delete this operations block?',
				deleteOperation: 'Delete selected operation?',
				deleteGroup: 'Delete this group?',
				deleteSelectedOperations: 'Delete selected operations?',
				ungroupSelected: 'Ungroup selected set?',
			},
			toasts: {
				created: 'Operations profile created',
				createError: 'Failed to create operations profile',
				saved: 'Operations profile saved',
				saveError: 'Failed to save operations profile',
				deleted: 'Operations profile deleted',
				deleteError: 'Failed to delete operations profile',
				importTitle: 'Import operations profile',
				importedCount: 'Imported: {{count}}',
				importError: 'Failed to import operations profiles',
				exportError: 'Export error',
			},
		};

export default enOperationProfiles;


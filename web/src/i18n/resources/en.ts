const en = {
	translation: {
		app: {
			loading: 'Loading application…',
			pleaseWait: 'Please wait.',
			retry: 'Retry',
			selectProfile: 'Select an Entity Profile or create a new one',
			createProfile: 'Create new profile',
		},
		leftRail: {
			agentCards: 'Profiles',
			settings: 'LLM settings',
			userPersons: 'Personas',
			instructions: 'Instructions',
			worldInfo: 'World Info',
			operationProfiles: 'Operations',
			appSettings: 'App settings',
			open: 'Open: {{section}}',
		},
		drawer: {
			toggleFullscreen: 'Toggle fullscreen',
			togglePlacement: 'Toggle side',
			close: 'Close panel',
			enterFullscreen: 'Open fullscreen',
			exitFullscreen: 'Exit fullscreen',
		},
		chat: {
			head: {
				entityFallback: 'Entity profile',
				selectChat: 'Select chat',
				createChat: 'Create chat',
				deleteChat: 'Delete chat',
				deleteChatConfirm: 'Delete chat?',
				branch: 'Branch',
				createBranch: 'Create branch',
			},
			input: {
				placeholder: 'Type a message...',
				bulkDeleteModePlaceholder: 'Message deletion mode is active',
				send: 'Send',
				continue: 'Continue',
				abort: 'Stop',
				actions: 'Send actions',
			},
			management: {
				openMenu: 'Conversation management',
				manageChats: 'Manage chats',
				manageBranches: 'Manage branches',
				bulkDelete: 'Delete messages',
				latestWorldInfoActivations: 'Latest World Info activations',
				latestWorldInfoActivationsTitle: 'Latest World Info activations',
				latestWorldInfoLoading: 'Loading activations…',
				latestWorldInfoError: 'Failed to load activations',
				latestWorldInfoEmpty: 'Latest activation data is unavailable.',
				latestWorldInfoGenerationId: 'Generation',
				latestWorldInfoStartedAt: 'Started at',
				latestWorldInfoStatus: 'Status',
				latestWorldInfoActivatedCount: 'Activated entries',
				latestWorldInfoWarnings: 'Warnings',
				latestWorldInfoNoEntries: 'No activated entries.',
				bulkSelectMessage: 'Select message for deletion',
				bulkSelectedCount: 'Selected: {{count}}',
				chatsTitle: 'Chats',
				branchesTitle: 'Branches',
				createChat: 'Create chat',
				createBranch: 'Create branch',
				active: 'Active',
				noMessages: 'No messages yet',
				selectChatFirst: 'Select a chat first.',
				renameChat: 'Rename chat',
				renameBranch: 'Rename branch',
				saveRename: 'Save name',
				cancelRename: 'Cancel rename',
				deleteChat: 'Delete chat',
				deleteBranch: 'Delete branch',
				deleteChatConfirm: 'Delete chat "{{name}}"?',
				deleteBranchConfirm: 'Delete branch "{{name}}"?',
			},
			message: {
				you: 'You',
				streaming: 'Generating…',
				saving: 'Saving…',
				assistantFallback: 'AI Assistant',
			},
			reasoning: {
				title: 'Reasoning',
				show: 'show',
				hide: 'hide',
			},
			avatarPreview: {
				title: 'Avatar preview',
				close: 'Close preview',
			},
			actions: {
				showActions: 'Show actions',
				hideActions: 'Hide actions',
				editMessage: 'Edit message',
				editPart: 'Edit part',
				deleteMessage: 'Delete message',
				deletePart: 'Delete part',
				hideFromPrompt: 'Hide from prompt',
				showInPrompt: 'Show in prompt',
				viewPrompt: 'View prompt',
				viewPromptUnavailable: 'Prompt diagnostics unavailable',
				cancelEdit: 'Cancel edit',
				confirmEdit: 'Confirm edit',
			},
			promptInspector: {
				title: 'Prompt inspector',
				loading: 'Loading diagnostics…',
				error: 'Load error',
				empty: 'No diagnostics data.',
				generationId: 'Generation',
				estimator: 'Token estimator',
				totalTokens: 'Total tokens',
				tabs: {
					tokens: 'Token stats',
					raw: 'Raw prompt',
				},
				byRole: 'By role',
				bySections: 'By sections',
				column: {
					part: 'Part',
					tokens: 'Tokens',
					share: 'Share',
				},
				roles: {
					system: 'System',
					user: 'User',
					assistant: 'Assistant',
				},
				sections: {
					systemInstruction: 'System instruction',
					chatHistory: 'Chat history',
					worldInfoBefore: 'World Info before',
					worldInfoAfter: 'World Info after',
					worldInfoDepth: 'World Info depth',
					worldInfoOutlets: 'World Info outlets',
					worldInfoAN: 'World Info AN',
					worldInfoEM: 'World Info EM',
				},
				turnCanonicalization: {
					title: 'Turn canonicalization (user)',
					before: 'Before',
					after: 'After',
					hook: 'Hook',
					opId: 'Operation',
					committedAt: 'Committed at',
				},
			},
			variants: {
				previous: 'Previous variant',
				next: 'Next variant',
				regenerate: 'Regenerate',
				delete: 'Delete variant',
				deleteDisabled: 'Cannot delete last variant',
				loading: 'Loading…',
				regenerateBlocked: 'Regeneration is disabled for an imported greeting',
			},
			confirm: {
				deleteMessageTitle: 'Delete message?',
				deleteMessageBody: 'This message will be removed from chat.',
				deleteVariantTitle: 'Delete variant?',
				deleteVariantBody: 'Only the current variant will be removed.',
				deletePartTitle: 'Delete part?',
				deletePartBody: 'Only the selected message part will be removed.',
				deleteBulkMessagesTitle: 'Delete selected messages?',
				deleteBulkMessagesBody: 'Messages to be deleted: {{count}}.',
			},
			debug: {
				debugUi: 'Debug UI',
				inspector: 'Inspector',
				on: 'on',
				off: 'off',
				show: 'show',
				hide: 'hide',
				rawParts: 'Raw parts',
			},
			defaults: {
				newChat: 'New chat',
			},
			errors: {
				branchIdRequired: 'branchId is required (activeBranchId is missing)',
				editablePartNotFound: 'No editable message part found',
			},
			toasts: {
				openChatError: 'Failed to open chat',
				selectInstructionError: 'Failed to select instruction',
				deleteChatError: 'Failed to delete chat',
				renameChatError: 'Failed to rename chat',
				activateBranchError: 'Failed to activate branch',
				createBranchError: 'Failed to create branch',
				renameBranchError: 'Failed to rename branch',
				deleteBranchError: 'Failed to delete branch',
				messageDeleted: 'Message deleted',
				partDeleted: 'Message part deleted',
				deleteMessageError: 'Failed to delete message',
				deletePartError: 'Failed to delete message part',
				bulkMessagesDeleted: 'Deleted messages: {{count}}',
				bulkDeleteMessageError: 'Failed to delete selected messages',
				variantSaved: 'Variant saved',
				saveEditError: 'Failed to save edit',
				switchVariantError: 'Failed to switch variant',
				variantDeleted: 'Variant deleted',
				deleteVariantError: 'Failed to delete variant',
				messageHiddenFromPrompt: 'Message hidden from prompt',
				messageShownInPrompt: 'Message included in prompt again',
				togglePromptVisibilityError: 'Failed to change prompt visibility for message',
				importItemError: 'Import error: {{name}}',
				importCompleted: 'Import completed',
				importFailed: 'Import failed',
				profileDeleted: 'Profile deleted',
				deleteProfileError: 'Failed to delete profile',
				updateProfileError: 'Failed to update profile',
				loadChatError: 'Failed to load chat',
				sendMessageError: 'Failed to send message',
				streamError: 'Stream error',
				regenerateError: 'Regeneration error',
				operationStarted: 'Operation {{name}} ({{hook}}) started',
				operationFinishedDone: 'Operation {{name}} ({{hook}}) completed',
				operationFinishedSkipped: 'Operation {{name}} ({{hook}}) skipped',
				operationFinishedError: 'Operation {{name}} ({{hook}}) failed',
				operationFinishedAborted: 'Operation {{name}} ({{hook}}) aborted',
			},
		},
		sidebars: {
			agentProfilesTitle: 'Entity profiles',
			createProfile: 'Create profile',
			settingsTitle: 'Settings',
			llmSettings: 'LLM settings',
			apiProvider: 'API Provider',
			ragProvider: 'RAG',
			userPersonsTitle: 'Persona list',
			selectPerson: 'Select persona',
			addPerson: 'Add persona',
			personsEmpty: 'No personas found',
			worldInfoTitle: 'World Info',
			selectWorldInfoBook: 'Select a World Info book',
			selectBookToEdit: 'Select a book to edit its JSON and bindings.',
		},
		appSettings: {
			title: 'App settings',
			tabs: {
				general: 'General',
				theming: 'Theming',
				debug: 'Debug',
			},
			sections: {
				general: 'General settings',
			},
			theming: {
				mode: 'Theme mode',
				light: 'Light',
				dark: 'Dark',
				auto: 'Auto',
				activePreset: 'Active preset',
				presetName: 'Preset name',
				presetDescription: 'Preset description',
				builtInReadOnly: 'Built-in presets are read-only. Create a new preset to edit.',
				lightTokens: 'Tokens (Light)',
				darkTokens: 'Tokens (Dark)',
				typography: 'Typography',
				markdown: 'Markdown style',
				customCss: 'Custom CSS',
				customCssHint: 'CSS is automatically scoped to the app shell.',
				actions: {
					createNew: 'Create new',
					createCopy: 'Create copy',
					import: 'Import',
					export: 'Export',
					delete: 'Delete',
					save: 'Save preset',
				},
				defaults: {
					newPresetName: 'New preset',
				},
				confirm: {
					deletePreset: 'Delete selected preset?',
				},
				errors: {
					invalidFormat: 'Invalid preset file format',
				},
				toasts: {
					presetCreated: 'Preset created',
					presetSaved: 'Preset saved',
					presetDeleted: 'Preset deleted',
					createFailed: 'Failed to create preset',
					saveFailed: 'Failed to save preset',
					deleteFailed: 'Failed to delete preset',
					importDone: 'Import completed',
					importedCount: 'Imported: {{count}}',
					importFailed: 'Failed to import preset',
					exportFailed: 'Failed to export preset',
				},
			},
			language: {
				label: 'Language',
			},
			languages: {
				ru: 'Russian',
				en: 'English',
			},
			openLastChat: {
				label: 'Open last chat',
				info: 'Automatically open the last active chat when the app starts',
			},
			autoSelectCurrentPersona: {
				label: 'Auto-select persona',
				info: 'Automatically select the relevant persona in the current chat',
			},
			debug: {
				label: 'Enable chat debug features',
				info: 'Shows debug UI in chat and enables SSE debug logs in browser console.',
				logsTitle: 'Console log filters',
				logsInfo: 'Choose which event types should be logged to the browser console.',
				actions: {
					enableAll: 'Enable all',
					disableAll: 'Disable all',
					operationsAndSnapshots: 'Operations + snapshots',
					resetDefaults: 'Reset defaults',
				},
				logs: {
					runLifecycle: {
						label: 'Run lifecycle',
						description: 'run.started, run.phase_changed, run.finished, and run.summary.',
					},
					operationStarted: {
						label: 'Operation started',
						description: 'operation.started with operation name and hook.',
					},
					operationFinished: {
						label: 'Operation finished',
						description: 'operation.finished with status and operation result (effects/debugSummary).',
					},
					operationCommits: {
						label: 'Effect commits',
						description: 'commit.effect_applied/skipped/error.',
					},
					mainLlmLifecycle: {
						label: 'Main LLM lifecycle',
						description: 'main_llm.started and main_llm.finished.',
					},
					streamText: {
						label: 'Text stream',
						description: 'main_llm.delta and llm.stream.delta (response tokens).',
					},
					streamReasoning: {
						label: 'Reasoning stream',
						description: 'main_llm.reasoning_delta and llm.stream.reasoning_delta.',
					},
					streamMeta: {
						label: 'Stream metadata',
						description: 'llm.stream.meta with chat, entry/part, and generation ids.',
					},
					streamDone: {
						label: 'Stream completion',
						description: 'llm.stream.done.',
					},
					streamErrors: {
						label: 'Stream errors',
						description: 'llm.stream.error.',
					},
					debugSnapshots: {
						label: 'Run debug snapshots',
						description: 'run.debug.state_snapshot and run.debug.main_llm_input.',
					},
					templateDebug: {
						label: 'Operation template debug',
						description: 'operation.debug.template with Liquid context and rendered output.',
					},
					other: {
						label: 'Other events',
						description: 'Any events that do not match categories above.',
					},
				},
			},
		},
		llmSettings: {
			selectSampler: 'Select algorithm',
			actions: {
				save: 'Save template',
				create: 'Create template',
				duplicate: 'Duplicate template',
				delete: 'Delete template',
			},
			fields: {
				temperature: {
					label: 'Temperature',
					tooltip: 'Controls response randomness. Higher values make output more random.',
				},
				maxTokens: {
					label: 'Max tokens',
					tooltip: 'Maximum number of tokens in the model response.',
				},
				topP: {
					label: 'Top P',
					tooltip: 'Controls diversity via nucleus sampling. Lower values make output more focused.',
				},
				frequencyPenalty: {
					label: 'Frequency penalty',
					tooltip: 'Reduces the chance of repeating the same phrases.',
				},
				presencePenalty: {
					label: 'Presence penalty',
					tooltip: 'Encourages the model to introduce new topics.',
				},
			},
		},
		rag: {
			providerLabel: 'RAG provider',
			tokens: { title: 'Token' },
			model: {
				manual: 'Embedding model',
				manualPlaceholder: 'e.g. text-embedding-3-small',
			},
			config: {
				title: 'RAG provider config',
				save: 'Save config',
			},
			presets: {
				title: 'RAG presets',
				active: 'Active preset',
				defaults: { newPresetName: 'New RAG preset' },
				actions: {
					createPrompt: 'Enter preset name',
					renamePrompt: 'Enter new preset name',
					create: 'Create',
					rename: 'Rename',
					save: 'Save',
					duplicate: 'Duplicate',
					apply: 'Apply',
					delete: 'Delete',
				},
				confirm: { delete: 'Delete selected preset?' },
			},
			toasts: {
				configSaved: 'RAG config saved',
				configSaveFailed: 'Failed to save RAG config',
			},
		},
		provider: {
			providerLabel: 'API provider',
			placeholders: {
				selectProvider: 'Select provider...',
				selectToken: 'Select token...',
				noTokens: 'No tokens',
				selectModel: 'Select model...',
				selectTokenFirst: 'Select a token first',
			},
			tokens: {
				title: 'Tokens',
				manage: 'Manage tokens',
			},
			config: {
				title: 'Provider configuration',
				baseUrl: 'Base URL',
				defaultModel: 'Default model (optional)',
				tokenPolicy: {
					title: 'Token policy',
					randomize: 'Use random token when more than one token exists',
					fallbackOnError: 'Fallback to next token on pre-stream errors',
				},
				anthropicCache: {
					title: 'Anthropic prompt cache',
					enabled: 'Enable Anthropic/OpenRouter prompt cache',
					depth: 'Cache depth (from tail)',
					ttl: 'Cache TTL',
					helpText: 'Depth is measured from the last message; the dynamic tail window stays uncached.',
				},
				save: 'Save config',
			},
			model: {
				title: 'Model',
				load: 'Load models',
				manual: 'Manual model id',
				manualPlaceholder: 'e.g. anthropic/claude-3.5-sonnet',
				applyManual: 'Apply',
				helpText: 'If no model is selected, provider `defaultModel` (if set) or provider default will be used.',
			},
			presets: {
				title: 'LLM presets',
				active: 'Active preset',
				defaults: {
					newPresetName: 'New LLM preset',
				},
				actions: {
					createPrompt: 'Enter preset name',
					create: 'Create',
					save: 'Save',
					duplicate: 'Duplicate',
					apply: 'Apply',
					delete: 'Delete',
				},
				confirm: {
					delete: 'Delete selected preset?',
				},
				toasts: {
					created: 'Preset created',
					saved: 'Preset saved',
					deleted: 'Preset deleted',
					applied: 'Preset applied',
					appliedWithWarnings: 'Preset applied with warnings',
					failed: 'Preset action failed',
				},
			},
			toasts: {
				configSaved: 'Provider config saved',
				configSaveFailed: 'Failed to save provider config',
			},
		},
		tokenManager: {
			title: 'Token manager',
			addToken: 'Add token',
			tokensFor: 'Tokens for `{{providerId}}`',
			empty: 'No tokens. Add your first token above.',
			activeSuffix: '(active)',
			editToken: 'Edit token',
			fields: {
				name: 'Name',
				token: 'Token',
				newTokenPlaceholder: 'New token (leave empty to keep {{hint}})',
			},
		},
		instructions: {
			title: 'Instructions',
			actions: {
				create: 'Create instruction',
				duplicate: 'Duplicate instruction',
				delete: 'Delete instruction',
				prerender: 'Prerender',
			},
			fields: {
				name: 'Name',
				templateText: 'Template (LiquidJS)',
				templateTextDescription: 'Syntax is validated on the backend when saving.',
				advancedMode: 'Advanced mode (ST-compatible)',
				fallbackTemplateText: 'Fallback templateText (basic compatibility)',
				fallbackTemplateTextDescription: 'Used when instruction mode is switched back to basic.',
				prerender: 'Prerender',
				prerenderDescription: 'Liquid render result on backend (without LLM generation).',
				promptBlocks: 'Prompt blocks',
				unsupportedBlock: 'unsupported in runtime',
				responseConfig: 'Response config',
				importSource: 'Import source',
				importFileName: 'Imported file',
				importedAt: 'Imported at',
				rawPreset: 'Raw ST preset (round-trip storage)',
			},
			placeholders: {
				name: 'Enter name',
				selectInstruction: 'Select instruction',
				addPromptBlock: 'Add prompt block',
				promptBlockContent: 'Prompt content',
			},
			defaults: {
				newInstruction: 'New instruction',
				importedInstruction: 'Imported instruction',
			},
			confirm: {
				deleteInstruction: 'Delete instruction?',
				exportStPreset: 'Export ST-compatible preset? (Cancel will export TaleSpinner format)',
				sensitiveRemove: 'Sensitive connection fields were found. Remove them during import?',
				sensitiveImportAsIs: 'Import sensitive fields as-is? (Cancel to abort import)',
			},
			toasts: {
				exportNotPossibleTitle: 'Export not possible',
				selectForExport: 'Select an instruction to export',
				importErrorTitle: 'Import error',
				importMissingTemplateText: 'File does not contain templateText',
				importSuccessTitle: 'Import successful',
				importReadError: 'Failed to read file',
				createErrorTitle: 'Failed to create instruction',
				saveErrorTitle: 'Failed to save instruction',
				deleteErrorTitle: 'Failed to delete instruction',
			},
		},
		userPersons: {
			fields: {
				name: 'Persona name',
				prefix: 'Prefix',
				description: 'Description',
			},
			badges: {
				active: 'Active',
			},
			placeholders: {
				searchByName: 'Search persona by name...',
			},
			filters: {
				showAdvancedTooltip: 'Show advanced filters',
				hideAdvancedTooltip: 'Hide advanced filters',
				sortLabel: 'Sort',
				pageSizeLabel: 'Page size',
			},
			pagination: {
				shownOfTotal: 'Shown {{shown}} of {{total}}',
			},
			empty: {
				noMatches: 'No personas match current filters',
			},
			editor: {
				title: 'Edit Persona',
			},
			confirm: {
				deleteTitle: 'Delete persona?',
				deleteBody: 'Persona "{{name}}" will be deleted permanently.',
			},
			toasts: {
				deleteError: 'Failed to delete persona',
			},
			defaults: {
				newPerson: 'New user',
			},
		},
		worldInfo: {
			fields: {
				name: 'Name',
				slug: 'Slug',
				description: 'Description',
				bookDataJson: 'Book data JSON',
				bindToChat: 'Bind to chat: {{chatTitle}}',
				noActiveChat: 'No active chat to bind',
			},
			actions: {
				createBook: 'Create World Info book',
				duplicateBook: 'Duplicate World Info book',
				importBook: 'Import World Info book',
				exportBook: 'Export World Info book',
				openEditor: 'Open editor',
				refresh: 'Refresh World Info',
				deleteBook: 'Delete World Info book',
				saveBook: 'Save book',
				saveSettings: 'Save settings',
			},
			settings: {
				title: 'World Info settings',
				notLoaded: 'Settings are not loaded.',
				scanDepth: 'Scan depth',
				minActivations: 'Min activations',
				minDepthMax: 'Min depth max',
				maxRecursionSteps: 'Max recursion steps',
				insertionStrategy: 'Insertion strategy',
				insertionStrategyEvenly: 'Evenly',
				insertionStrategyCharacterFirst: 'Character first',
				insertionStrategyGlobalFirst: 'Global first',
				budgetPercent: 'Budget percent',
				budgetCapTokens: 'Budget cap tokens',
				contextWindowTokens: 'Context window tokens',
				recursive: 'Recursive',
				overflowAlert: 'Overflow alert',
				includeNames: 'Include names',
				caseSensitive: 'Case sensitive',
				matchWholeWords: 'Match whole words',
				useGroupScoring: 'Use group scoring',
			},
			confirm: {
				deleteBook: 'Delete selected World Info book?',
				discardChanges: 'Discard unsaved changes?',
			},
			editor: {
				title: 'World Info editor',
				entriesTitle: 'Entries',
				addEntry: 'Add entry',
				duplicateEntry: 'Duplicate entry',
				deleteEntry: 'Delete entry',
				searchEntries: 'Search entries',
				selectEntry: 'Select an entry to edit',
				entryTitle: 'Entry #{{id}}',
				noEntries: 'No entries',
				noKeys: 'No keys',
				tabs: {
					content: 'Content',
					matching: 'Matching',
					activation: 'Activation',
					timing: 'Timing',
					advanced: 'Advanced',
				},
				fields: {
					comment: 'Comment',
					strategy: 'Strategy',
					content: 'Content',
					position: 'Position',
					order: 'Order',
					depth: 'Depth',
					outletName: 'Outlet name',
					key: 'Primary keys',
					keysecondary: 'Secondary keys',
					selective: 'Selective match',
					selectiveLogic: 'Selective logic',
					scanDepth: 'Scan depth override',
					caseSensitive: 'Case sensitive',
					matchWholeWords: 'Match whole words',
					useGroupScoring: 'Use group scoring',
					matchPersonaDescription: 'Match persona description',
					matchCharacterDescription: 'Match character description',
					matchCharacterPersonality: 'Match character personality',
					matchCharacterDepthPrompt: 'Match character depth prompt',
					matchScenario: 'Match scenario',
					matchCreatorNotes: 'Match creator notes',
					constant: 'Constant',
					disable: 'Disabled',
					useProbability: 'Use probability',
					probability: 'Probability (%)',
					ignoreBudget: 'Ignore budget',
					excludeRecursion: 'Exclude recursion',
					preventRecursion: 'Prevent recursion',
					delayUntilRecursion: 'Delay until recursion',
					group: 'Group',
					groupOverride: 'Group override',
					groupWeight: 'Group weight',
					sticky: 'Sticky',
					cooldown: 'Cooldown',
					delay: 'Delay',
					triggers: 'Triggers',
					role: 'Role',
					uid: 'UID',
					automationId: 'Automation id',
					characterFilterExclude: 'Character filter exclude mode',
					characterFilterNames: 'Character names filter',
					characterFilterTags: 'Character tags filter',
					extensionsJson: 'Extensions JSON',
					vectorized: 'Vectorized',
					addMemo: 'Add memo',
					additionalMatchingSources: 'Additional matching sources',
					advanced: 'Advanced',
				},
				strategy: {
					normal: 'Normal',
					constant: 'Constant',
					vectorized: 'Vectorized',
				},
				inherit: 'Inherit',
				true: 'True',
				false: 'False',
			},
			defaults: {
				newBook: 'New World Info book',
			},
			toasts: {
				bookNameRequired: 'Book name is required',
				invalidBookJson: 'Invalid book JSON',
				exportFailed: 'Failed to export book',
				createErrorTitle: 'Failed to create World Info',
				duplicateErrorTitle: 'Failed to duplicate World Info',
				deleteErrorTitle: 'Failed to delete World Info',
				bookSaved: 'World Info saved',
				saveBookErrorTitle: 'Failed to save book',
				settingsSaved: 'World Info settings saved',
				saveSettingsErrorTitle: 'Failed to save settings',
				bindingUpdated: 'Chat binding updated',
				bindingUpdateErrorTitle: 'Failed to update binding',
				importedBook: 'Imported {{name}}{{warningSuffix}}',
				importErrorTitle: 'Failed to import book',
				loadBooksErrorTitle: 'Failed to load World Info list',
				loadSettingsErrorTitle: 'Failed to load World Info settings',
				loadBookErrorTitle: 'Failed to load World Info book',
			},
		},
		operationProfiles: {
			sidebar: {
				title: 'Operations',
			},
			defaults: {
				newProfile: 'New profile',
				copyName: '{{name}} (copy)',
				untitledOperation: 'Untitled operation',
			},
			actions: {
				openNodeEditor: 'Open Node Editor',
				discard: 'Discard changes',
				resetSessionId: 'Reset session id',
				createProfile: 'Create profile',
				duplicateProfile: 'Duplicate profile',
				deleteProfile: 'Delete profile',
				exportProfile: 'Export profile',
				importProfiles: 'Import profiles',
				addOperation: 'Add operation',
				deleteOperation: 'Delete operation',
				group: 'Group',
				ungroup: 'Ungroup',
			},
			empty: {
				selectProfile: 'Select a profile to edit operations.',
			},
			profilePicker: {
				noneSelected: 'No profile selected',
				select: 'Select profile',
				current: 'Current profile',
			},
			operations: {
				title: 'Operations',
				visibleOfTotal: '{{visible}} shown of {{total}}',
				empty: 'No operations yet. Add one to start editing.',
			},
			inspector: {
				title: 'Operation inspector',
				noneSelected: 'No operation selected',
				operationNumber: 'Operation #{{number}}',
				selectFromList: 'Select an operation from the list to edit.',
			},
			profileSettings: {
				title: 'Profile settings',
				profileName: 'Profile name',
				profileEnabled: 'Profile enabled',
				executionMode: 'Execution mode',
				sessionId: 'Operation profile session id',
				sessionIdInfo: 'Reset this id if you need a new validation scope and change-grouping scope.',
				invalidJson: 'Invalid JSON',
			},
			operationEditor: {
				title: 'Operation',
				unsaved: 'Unsaved',
			},
			fields: {
				operationName: 'Operation name',
				kind: 'Kind',
				kindDescription: 'Determines the kind-specific parameters section below.',
				opId: 'opId: {{value}}',
			},
			sections: {
				basics: 'Basics',
				kindSpecific: 'Kind parameters',
				execution: 'Execution',
				effectsOutput: 'Effects / Output',
				advanced: 'Advanced',
			},
			sectionsLabels: {
				description: 'Description',
				enabled: 'Enabled',
				required: 'Required',
				hook: 'Hook',
				triggers: 'Triggers',
				order: 'Order',
				dependsOn: 'Depends on',
				effectType: 'Effect type',
				artifactTag: 'Artifact tag',
				persistence: 'Persistence',
				usage: 'Usage',
				semantics: 'Semantics',
				promptTimeEffect: 'Prompt-time effect',
				mode: 'Mode',
				sourceOptional: 'Source (optional)',
				role: 'Role',
				depthFromEnd: 'atDepth',
				target: 'Target',
			},
			tooltips: {
				description: 'Short description displayed in operation list, node labels, and profile docs.',
				enabled: 'Disabled operations are skipped and do not commit effects.',
				required: 'Required operations must finish with done status. Otherwise, running the corresponding hook fails.',
				hook: 'Choose whether the operation runs before or after the main LLM call.',
				triggers: '`generate` runs on a new turn; `regenerate` runs on a new assistant variant.',
				order: 'Commit order is deterministic: dependencies first, then lower order, then opId.',
				dependsOn: 'Operation waits for all dependencies with done status. Failed or skipped dependency blocks start.',
				effectType: 'Choose how rendered result is applied during commit at runtime.',
				artifactTag: 'Use a tag without `art` prefix. Each tag in profile should have a single writer.',
				persistence: '`persisted` survives turns; `run_only` exists only during current run.',
				usage: 'Choose whether artifact is used in prompt, UI, both, or internal only.',
				semantics: 'Semantic label for consumers, e.g. "state" or "log/feed".',
				promptTimeEffect: 'Effect kind for prompt-time text insertion.',
				mode: '`prepend` => payload + system; `append` => system + payload; `replace` => system = payload.',
				sourceOptional: 'Optional source label for debugging/explainability.',
				role: 'Role for synthetic prompt message.',
				depthFromEnd:
					'0 inserts at the end; N inserts N messages from the end. Large values clamp right after the main system instruction.',
				target: '`before_main_llm` allows only target=user; `after_main_llm` allows user or assistant.',
			},
			outputType: {
				artifacts: 'Artifacts',
				promptTime: 'Prompt-time effects',
				turnCanonicalization: 'Turn canonicalization effects',
			},
			outputNotes: {
				promptTimePayloadSource: 'Effect payload source is template-rendered text.',
				turnCanonicalization: 'Current `replace_text` mode: selected turn part is overwritten with template output.',
			},
			promptTimeKind: {
				appendAfterLastUser: 'prompt.append_after_last_user',
				systemUpdate: 'prompt.system_update',
				insertAtDepth: 'prompt.insert_at_depth',
			},
			kind: {
				template: 'Template',
				llm: 'LLM',
				rag: 'RAG',
				tool: 'Tool',
				compute: 'Compute',
				transform: 'Transform',
				legacy: 'Legacy',
			},
			kindSection: {
				jsonParamsLabel: '{{kindLabel}} params (JSON)',
				jsonParamsInfo: 'Kind parameters are stored as JSON object in config.params.params.',
				template: {
					description: 'Template operations render text from available variables and pass result to output effects.',
					strictVariables: 'Strict variables',
					strictVariablesInfo: 'When enabled, template can use only declared variables.',
					templateText: 'Template text',
					templateTextInfo: 'Operation template body.',
				},
				compute: {
					description: 'Configure deterministic computations or transformations over structured inputs.',
				},
				legacy: {
					description: 'Use this section for compatibility payload required by legacy executors.',
				},
				llm: {
					description: 'Configure direct model call parameters for this operation.',
					blocks: {
						prompt: 'Prompt',
						provider: 'Provider',
						samplers: 'Samplers',
						reliability: 'Reliability',
					},
					strictVariables: 'Strict variables',
					strictVariablesInfo: 'If enabled, Liquid templates throw when unknown variables are used.',
					system: 'System prompt',
					systemInfo: 'Optional system message template for this operation.',
					prompt: 'User prompt',
					promptInfo: 'Required prompt template rendered against operation context.',
					samplerPreset: 'Sampler preset',
					samplerPresetInfo: 'Selecting a preset copies its values into sampler overrides.',
					outputMode: 'Result mode',
					outputModeInfo: '`text` stores raw model output; `json` requires strict JSON parse.',
					outputModeText: 'Text',
					outputModeJson: 'Strict JSON',
					jsonParseMode: 'JSON parse mode',
					jsonParseModeInfo: 'How to extract JSON payload from model output before parsing.',
					jsonParseModeHintRaw: 'Parse the whole response as JSON without extraction.',
					jsonParseModeHintMarkdownCodeBlock: 'Extract content from the first fenced code block (```json ... ```).',
					jsonParseModeHintCustomRegex: 'Apply custom regex to output; first capture group is used if present.',
					jsonParseModeRaw: 'Raw response',
					jsonParseModeMarkdownCodeBlock: 'From markdown code block',
					jsonParseModeCustomRegex: 'Custom regex',
					jsonCustomPattern: 'Custom regex pattern',
					jsonCustomPatternInfo: 'Use JS regex. First capture group (if present) is used as JSON payload.',
					jsonCustomFlags: 'Custom regex flags',
					jsonCustomFlagsInfo: 'JS regex flags, e.g. `i` or `gm`.',
					timeoutMs: 'Timeout (ms)',
					timeoutMsInfo: 'Per-attempt timeout for the provider request.',
					retryMaxAttempts: 'Retry max attempts',
					retryMaxAttemptsInfo: 'Total attempts including the first call.',
					retryBackoffMs: 'Retry backoff (ms)',
					retryBackoffMsInfo: 'Wait time between retry attempts.',
					strictSchemaValidation: 'Strict schema validation',
					strictSchemaValidationInfo: 'Validate parsed JSON response against schema with zod.',
					jsonSchema: 'JSON schema (typed template)',
					jsonSchemaInfo: 'Use JSON object with type descriptors, optional fields, arrays and nested objects.',
					retryOn: {
						label: 'Retry on',
						timeout: 'Timeout',
						providerError: 'Provider error',
						rateLimit: 'Rate limit',
					},
					retryOnInfo: 'Error classes that are allowed to trigger a retry.',
					schemaHelp: {
						open: 'How to write schema',
						title: 'JSON Schema Format',
						description: 'Schema uses a lightweight typed JSON format and is compiled to zod.',
						ruleTypeDescriptor: 'Use "type: description" for string descriptors (string, number, boolean, null, integer).',
						ruleOptional: 'Append "?" to key name to mark field optional.',
						ruleArray: 'For arrays, pass an example array with one item schema, e.g. ["string: tag"] or [{...}].',
						ruleLiterals: 'Numeric/boolean/null literals infer primitive type automatically.',
					},
				},
				rag: {
					description: 'Configure retrieval source and ranking parameters for context assembly.',
				},
				tool: {
					description: 'Define tool call name, arguments, and runtime limits.',
				},
				transform: {
					description: 'Describe post-processing steps for operation outputs.',
				},
			},
			filters: {
				allKinds: 'All kinds',
				searchPlaceholder: 'Search by name, id, or kind',
				searchAria: 'Search operations',
				byKindAria: 'Filter by operation kind',
				allStates: 'All states',
				enabledOnly: 'Enabled only',
				disabledOnly: 'Disabled only',
				byEnabledAria: 'Filter by enabled',
				allRequiredStates: 'All required states',
				requiredOnly: 'Required only',
				optionalOnly: 'Optional only',
				byRequiredAria: 'Filter by required',
				noMatches: 'No operations match current filters.',
			},
			nodeEditor: {
				title: 'Node Editor',
				subtitle: 'Nodes represent operations. Edges are dependsOn links. Select a node to edit details.',
				hideOperation: 'Hide operation',
				showOperation: 'Show operation',
				autoLayout: 'Auto-layout',
				jsonError: 'JSON error',
				graphTab: 'Graph',
				inspectorTab: 'Inspector',
				groupsPlaceholder: 'Groups',
				selectNode: 'Select a node to edit operation details.',
				groupNamePrompt: 'Group name',
				groupNameDefault: 'Group {{index}}',
			},
			groupEditor: {
				title: 'Edit group',
				name: 'Name',
				namePlaceholder: 'Group name',
				background: 'Background',
				backgroundPlaceholder: 'CSS color (alpha will be ignored)',
				backgroundHint: 'Transparency is fixed for default groups; you control only base color.',
				delete: 'Delete group',
			},
			placeholders: {
				none: 'None',
			},
			confirm: {
				deleteProfile: 'Delete this operations profile?',
				deleteOperation: 'Delete selected operation?',
				deleteGroup: 'Delete this group?',
				deleteSelectedOperations: 'Delete selected operations?',
				ungroupSelected: 'Ungroup selected set?',
			},
			toasts: {
				created: 'Operations profile created',
				createError: 'Failed to create operations profile',
				saved: 'Operations profile saved',
				saveError: 'Failed to save operations profile',
				deleted: 'Operations profile deleted',
				deleteError: 'Failed to delete operations profile',
				importTitle: 'Import operations profile',
				importedCount: 'Imported: {{count}}',
				importError: 'Failed to import operations profiles',
				exportError: 'Export error',
			},
		},
		agentCards: {
			kindLabel: 'Type: {{kind}}',
			tokensApprox: '~{{count}} tok',
			worldInfoBadgeTooltip: 'World Info: {{name}}',
			worldInfoBadgeAria: 'Profile has linked World Info',
			badges: {
				active: 'Active',
			},
			worldInfoImport: {
				title: 'Import linked World Info',
				description: 'The imported profiles contain character_book data. Select profiles to import their World Info and auto-bind it.',
				confirm: 'Import',
				errorsTitle: 'Import errors',
				emptySelection: 'Select at least one profile.',
			},
			worldInfo: {
				none: 'Not linked',
				notBound: 'No World Info linked for this profile.',
				bindingLabel: 'Linked World Info book',
				openEditor: 'Open World Info editor',
			},
			actions: {
				favorite: 'Add to favorites',
				unfavorite: 'Remove from favorites',
			},
			filters: {
				searchPlaceholder: 'Search by name, description, personality, scenario, tags',
				favoriteModeLabel: 'Favorites',
				favoriteModeAll: 'Normal',
				favoriteModeOnly: 'Favorites only',
				favoriteModeWithout: 'Without favorites',
				showAdvancedTooltip: 'Show advanced filters',
				hideAdvancedTooltip: 'Hide advanced filters',
				sortLabel: 'Sort',
				tagsLabel: 'Tags',
				tagsPlaceholder: 'Filter by tags',
				tokenMinLabel: 'Tokens min',
				tokenMaxLabel: 'Tokens max',
				pageSizeLabel: 'Page size',
			},
			pagination: {
				shownOfTotal: 'Shown {{shown}} of {{total}}',
			},
			empty: {
				noMatches: 'No profiles match current filters',
			},
			editor: {
				title: 'Edit Entity Profile',
				avatarHint: 'Click avatar to upload a new image',
				tabs: {
					basic: 'Basic',
					chat: 'Chat',
					greetings: 'Greetings',
					system: 'System',
					worldInfo: 'World Info',
					advanced: 'Advanced JSON',
				},
				fields: {
					name: 'Name',
					description: 'Description',
					personality: 'Personality',
					scenario: 'Scenario',
					firstMes: 'First message',
					mesExample: 'Message examples',
					tags: 'Tags',
					alternateGreetings: 'Alternate greetings',
					systemPrompt: 'System prompt',
					postHistoryInstructions: 'Post history instructions',
					creatorNotes: 'Creator notes',
					creator: 'Creator',
					characterVersion: 'Character version',
					extensionsJson: 'Extensions (JSON)',
					extensionsJsonDescription: 'Raw JSON block from CharSpec',
					characterBookJson: 'Character book (JSON)',
					characterBookJsonDescription: 'Raw JSON block from CharSpec',
				},
				actions: {
					removeAvatar: 'Remove avatar',
					addGreeting: 'Add greeting',
					moveUp: 'Move up',
					moveDown: 'Move down',
				},
				emptyGreetings: 'No alternate greetings yet',
				greetingLabel: 'Greeting #{{index}}',
				errors: {
					invalidExtensionsJson: 'Invalid JSON in extensions field',
					invalidCharacterBookJson: 'Invalid JSON in character_book field',
				},
			},
			confirm: {
				deleteProfile: 'Delete profile "{{name}}"?',
				deleteProfileTitle: 'Delete profile?',
				deleteProfileBody: 'Profile "{{name}}" will be deleted permanently.',
			},
			toasts: {
				tooManyFiles: 'Too many files (maximum 10)',
				fileTooLarge: 'File is too large (maximum 10MB)',
				uploadFailed: 'Failed to upload files',
				exportFailed: 'Failed to export profile',
				worldInfoImportCompleted: 'World Info import completed',
				worldInfoImportCount: 'Imported and linked: {{count}}',
				worldInfoImportFailedTitle: 'World Info import error',
			},
		},
		files: {
			toasts: {
				exportErrorTitle: 'Export error',
				selectForExport: 'Select item to export',
				importErrorTitle: 'Import error',
				missingDataForEntity: 'File does not contain data for {{name}}',
				importSuccessTitle: 'Import successful',
				importSuccessDescription: '{{name}} imported successfully',
				readError: 'Failed to read file',
			},
		},
		avatar: {
			toasts: {
				errorTitle: 'Error',
				uploadImageOnly: 'Please upload an image',
				uploadFileError: 'File upload error',
				successTitle: 'Success',
				avatarUploaded: 'Avatar uploaded',
				avatarUploadFailed: 'Failed to upload avatar',
			},
		},
		dialogs: {
			textarea: {
				openFullscreen: 'Open fullscreen',
				title: 'Editing',
				tabs: {
					edit: 'Edit',
					preview: 'Preview',
				},
			},
			liquidDocs: {
				open: 'Open Liquid docs',
				sections: {
					usage: 'Usage',
					variables: 'Variables',
					macros: 'Macros',
					examples: 'Examples',
				},
				contexts: {
					instruction: {
						title: 'Instruction Liquid docs',
						usage: 'Used when rendering chat instructions before generation.',
					},
					operationTemplate: {
						title: 'Template operation Liquid docs',
						usage: 'Used by operation kind=template for rendered effect payloads.',
					},
					operationLlm: {
						title: 'LLM operation Liquid docs',
						usage: 'Used by operation kind=llm for system and user prompt rendering.',
					},
					entityProfile: {
						title: 'Entity profile Liquid docs',
						usage: 'Liquid can be resolved in profile text fields directly and through multi-pass usage in other templates.',
					},
					worldInfoEntry: {
						title: 'World Info Liquid docs',
						usage: 'Used when rendering World Info entry content in runtime context.',
					},
					chatManualEdit: {
						title: 'Manual edit Liquid docs',
						usage: 'Used when chat message part is edited manually and rendered via Liquid.',
					},
				},
				variables: {
					char: 'Character object alias. Works as string and as object.',
					charName: 'Character name from current entity profile.',
					user: 'Selected user persona object alias.',
					userName: 'Selected user persona name.',
					chatId: 'Current chat identifier.',
					chatTitle: 'Current chat title.',
					messages: 'Prompt-visible history as array of { role, content }.',
					now: 'Current ISO timestamp generated on server.',
					rag: 'Reserved retrieval context object.',
					description: 'Alias for char.description.',
					scenario: 'Alias for char.scenario.',
					personality: 'Alias for char.personality.',
					system: 'Alias for char.system_prompt.',
					persona: 'Alias for user persona description.',
					mesExamples: 'Alias for character example messages field.',
					mesExamplesRaw: 'Raw character example messages field before transforms.',
					anchorBefore: 'Alias for world info anchor before block.',
					anchorAfter: 'Alias for world info anchor after block.',
					wiBefore: 'World Info text inserted before history/system area.',
					wiAfter: 'World Info text inserted after history/system area.',
					loreBefore: 'Alias for World Info before block.',
					loreAfter: 'Alias for World Info after block.',
					outlet: 'Joined outlet map, key to rendered text.',
					outletEntries: 'Outlet map, key to array of raw rendered blocks.',
					anTop: 'Author note entries for top insertion.',
					anBottom: 'Author note entries for bottom insertion.',
					emTop: 'Extension memory entries for top insertion.',
					emBottom: 'Extension memory entries for bottom insertion.',
					promptSystem: 'Resolved system prompt visible in operation context.',
					art: 'Operation artifacts map by tag.',
					artValue: 'Artifact value by tag, for example art.note.value.',
				},
				macros: {
					trim: 'Removes surrounding blank lines around macro location.',
					outlet: 'Shortcut to outlet map lookup by key.',
					random: 'Chooses one option at render time and inserts text.',
				},
				examples: {
					instructionSystem: {
						title: 'System template with world info',
					},
					instructionOutlet: {
						title: 'Outlet plus random tone',
					},
					operationTemplateArtifacts: {
						title: 'Read promptSystem and artifacts',
					},
					operationTemplatePromptTime: {
						title: 'Compose prompt-time payload',
					},
					operationLlmSystem: {
						title: 'LLM system template',
					},
					operationLlmPrompt: {
						title: 'LLM user prompt template',
					},
					entityProfileGreeting: {
						title: 'Greeting template',
					},
					entityProfileIndirect: {
						title: 'Indirect multi-pass profile usage',
					},
					worldInfoEntryCharacter: {
						title: 'World Info character-aware line',
					},
					worldInfoEntryOutlet: {
						title: 'World Info outlet merge',
					},
					chatManualEditRewrite: {
						title: 'Manual edit rewrite template',
					},
					chatManualEditHistory: {
						title: 'Manual edit history-aware template',
					},
				},
			},
		},
		sortFilter: {
			placeholders: {
				searchByName: 'Search by name...',
				sort: 'Sort...',
			},
			filters: {
				byName: 'By name',
			},
			sort: {
				alphaAsc: 'Alphabetical (A-Z)',
				alphaDesc: 'Alphabetical (Z-A)',
				newest: 'Newest first',
				oldest: 'Oldest first',
				latest: 'Recently updated',
				favorites: 'Favorites',
				mostChats: 'Most chats',
				fewestChats: 'Fewest chats',
				mostTokens: 'Most tokens',
				fewestTokens: 'Fewest tokens',
				random: 'Random',
			},
		},
		common: {
			create: 'Create',
			duplicate: 'Duplicate',
			delete: 'Delete',
			up: 'Up',
			down: 'Down',
			import: 'Import',
			export: 'Export',
			refresh: 'Refresh',
			enabled: 'Enabled',
			save: 'Save',
			cancel: 'Cancel',
			close: 'Close',
			edit: 'Edit',
			add: 'Add',
			info: 'Info',
			confirmDeleteEntity: 'Are you sure you want to delete this {{name}}?',
			copyName: '{{name}} (copy)',
		},
	},
};

export default en;

---
description: Backend, Server, Node.js, Express, SQLite, API design, services layer and other backend or server features
alwaysApply: false
---

## Role

You are a Senior Backend Developer for this project (Node.js + Express + TypeScript).
Write production-grade code: strict types, predictable HTTP behavior, clear module boundaries, and no “god files”.

## Current backend stack (this repo)

- **Location**: `server/` (Node.js + TypeScript)
- **HTTP**: **Express v5**
- **Validation**: **zod** (+ `validate` middleware)
- **LLM provider**: **OpenRouter** via **OpenAI SDK** (`openai`)
- **Files/media**: `multer` uploads + static `/media` from `data/media`
- **Persistence (current reality)**:
  - primary: **JSON files under `data/`** (legacy / transitional)
  - WIP: **SQLite + Drizzle** (`better-sqlite3` + `drizzle-orm`, migrations in `server/drizzle/`)
  - target: **fully move away from JSON to DB** (do not expand JSON persistence in new code)
- **Package manager**: **Yarn Classic (1.x)** (do not suggest npm/pnpm)

## Non-negotiable constraints

- **Package manager:** use **Yarn only**. Never suggest npm/pnpm.
- **Runtime:** Node.js, TypeScript. Build output goes to `server/dist/` via `tsc`.
- **Framework:** **Express**. Keep HTTP layer thin; orchestration lives outside routers.
- **Comments:** if you write comments in code, they must be **in English**.
- **No heavy infra**: don’t introduce new frameworks/ORMs/loggers unless explicitly requested (Drizzle is already present).

## Repository structure (follow existing layout)

- `server/src/index.ts` — Express app bootstrap: middleware, routes, final `errorHandler`, listen.
- `server/src/routes/*` — **legacy** “handwritten” routes (still used).
- `server/src/api/*` — **preferred** modular API (routers created via factories/controllers).
- `server/src/core/*` — framework glue:
  - `core/middleware/*` — `asyncHandler`, `errorHandler`, `validate`
  - `core/http/response.ts` — `ApiResult` contract (`data` / `error`, `raw`, `headers`, `status`)
  - `core/factories/*` — `RouteFactory` + controllers factory (`CrudController`, `ConfigController`, `GeneralController`)
  - `core/services/*` — file-based “repositories” (`BaseService`, `ConfigService`)
  - `core/types/*` — shared backend types (`BaseEntity`, `Logger`, etc.)
- `server/src/services/*` — domain services (agent cards, templates, settings, OpenRouter, files, etc.)
- `server/src/db/*` + `server/drizzle/*` — SQLite+Drizzle scaffolding (migrations are applied via script, runtime usage may be WIP)
- `shared/types/*` — shared contracts between frontend and backend

## Architectural rules (strict enough to keep sane)

- **HTTP layer** (`routes/*`, `api/*`, `core/factories/*`) may import:
  - domain services (`server/src/services/*`)
  - core helpers (`server/src/core/*`)
  - shared types (`shared/types/*`)
- **Domain services** must not import Express request/response types and must not know how HTTP is shaped.
- **File-based persistence** lives in `core/services/*` (today) and should be treated as an infrastructure detail.
- Avoid circular dependencies. If two domains need each other, extract a small shared abstraction/module.

## TypeScript rules (strict)

- **No new `any`** in new/modified code. Use `unknown` + guards, or proper generics.
- Public (exported) functions must have explicit return types.
- Prefer `interface` for object shapes and `type` for unions/utility types.
- Do not use `// @ts-ignore`. If absolutely unavoidable, use `// @ts-expect-error -- <reason>` with an English reason.
- Prefer `import type { ... }` for type-only imports.

## HTTP/API conventions (Express)

- Validate and normalize input early (params/query/body) using **zod**.
  - Prefer the shared `validate({ params, query, body })` middleware.
  - Avoid `req.body as Type` without runtime validation.
- Prefer the **“new” API style** for new endpoints:
  - return `ApiResult` from handlers (`{ data: ... }`, or `{ data, headers, raw: true }`)
  - wrap handlers with `asyncHandler`
- **Errors**:
  - throw `HttpError(status, message, code?, details?)` for expected failures
  - rely on the final `errorHandler` middleware to shape `ApiErrorBody`
  - never leak stack traces/secret values to clients
- Use early returns and small functions to keep flow readable.

## Streaming (SSE) & concurrency

- For SSE endpoints (generation streaming):
  - always set proper SSE headers
  - track streams by id and ensure cleanup (`finally` removing controllers)
  - support aborts via `AbortController`
- For heavy I/O (files/images):
  - avoid unbounded parallelism
  - validate file types/sizes
  - prefer async FS (`fs/promises`) over sync FS in request path

## Data paths & persistence rules (important for correctness)

- The project stores data under `server/data/` (JSON entities/config + media).
- **Migration direction**: JSON persistence is legacy. For new features, prefer **DB-backed storage** (Drizzle/SQLite) or introduce a repository abstraction so the storage can be swapped without rewriting HTTP/services.
- **Do not rely on `__dirname` for data paths in runtime-critical code** (it breaks after `tsc` into `dist/`).
  - Prefer `process.cwd()` + env vars (e.g. `DB_PATH`) for path resolution.
  - If you introduce a new path, make it configurable and keep one source of truth.
- File-based “DB” writes should be safe:
  - avoid partially-written JSON (consider atomic write: temp → rename)
  - consider minimal in-memory locking for concurrent writes if you touch that code

## Security rules (mandatory)

- **Never serve `data/` wholesale as static** (it can expose configs/secrets). Only serve explicitly public folders (e.g. `data/media` via `/media`).
- **Secrets**:
  - do not return API keys in API responses (mask in UI-facing endpoints)
  - prefer env/config for secrets (today some config may still live in `data/config/*` — treat as sensitive)
- Always enforce payload limits for JSON and uploads; don’t increase limits without a clear reason.

## No “god files” (mandatory decomposition)

- **One file = one responsibility.**
- If a module grows beyond ~200 lines or mixes concerns (HTTP + business + infra), split it:
  - route handlers stay in `routes/`
  - orchestration rules in `services/`
  - framework glue in `core/`
  - persistence/infra in `core/services/` and/or `db/`

## How to verify (mandatory)

After completing **any** backend coding task, run server checks and fix issues until they are clean:

- From repo root:
  - `yarn verify:server`
- Or directly:
  - `yarn -C server verify`

Quick commands (server):

- `yarn -C server typecheck`
- `yarn -C server lint`
- `yarn -C server lint:ci` (CI strict)

If you worked on DB migrations:

- `yarn -C server db:migrate`

---
description: Backend (server/): Node.js + Express + TypeScript + SQLite/Drizzle — API and services protocol
alwaysApply: false
---

## Backend task protocol

When editing or creating backend code under `server/`, follow these **non‑negotiable rules**.

### Output format

- Prefer returning:
  - a single TypeScript code block for the relevant file(s), or
  - a minimal diff description + code block
- Keep narrative text minimal; focus on code and short rationales.
- Ask for clarification before large changes if the requirements are ambiguous.

### Backend stack (must respect)

- Location: `server/` (Node.js + TypeScript)
- HTTP: **Express v5**
- Validation: **zod** with shared `validate` middleware
- LLM provider: **OpenRouter** via **OpenAI SDK** (`openai`)
- Files/media: `multer` uploads + static `/media` from `data/media`
- Persistence (current reality):
  - primary: JSON files under `data/` (legacy / transitional)
  - WIP: SQLite + Drizzle (`better-sqlite3` + `drizzle-orm`, migrations in `server/drizzle/`)
  - target: fully move away from JSON; do **not** expand JSON persistence
- Package manager: **Yarn Classic (1.x)** — never suggest npm/pnpm

### Architecture and module boundaries

- Follow existing structure:
  - `server/src/index.ts` — Express app bootstrap (middleware, routes, final `errorHandler`, listen)
  - `server/src/routes/*` — legacy routes
  - `server/src/api/*` — preferred modular API (factory-based routers/controllers)
  - `server/src/core/*` — framework glue:
    - `core/middleware/*` — `asyncHandler`, `errorHandler`, `validate`
    - `core/http/response.ts` — `ApiResult` contract
    - `core/factories/*` — route and controller factories
    - `core/services/*` — file-based repositories
    - `core/types/*` — shared backend types
  - `server/src/services/*` — domain services
  - `server/src/db/*` + `server/drizzle/*` — SQLite+Drizzle
  - `shared/types/*` — shared contracts with frontend
- Import/architecture rules:
  - HTTP layer (`routes/*`, `api/*`, `core/factories/*`) may import:
    - domain services (`server/src/services/*`)
    - core helpers (`server/src/core/*`)
    - shared types (`shared/types/*`)
  - Domain services must **not** import Express request/response types and must not depend on HTTP layer.
  - File-based persistence lives in `core/services/*` and is an implementation detail.
  - Avoid circular dependencies; if needed, extract a small shared module.

### TypeScript rules

- No new `any` in new or modified code.
- Exported functions must have explicit return types.
- Prefer `interface` for object shapes, `type` for unions/utility types.
- Do not use `// @ts-ignore`. If absolutely necessary, use `// @ts-expect-error -- <reason>` (English reason).
- Prefer `import type { ... }` for type-only imports.

### HTTP/API conventions

- Validate and normalize input early using **zod** and `validate({ params, query, body })`.
- Avoid `req.body as Type` without runtime validation.
- Prefer the **“new” API style** for new endpoints:
  - handlers return `ApiResult` (`{ data: ... }` or `{ data, headers, raw: true }`)
  - handlers are wrapped with `asyncHandler`
- Error handling:
  - throw `HttpError(status, message, code?, details?)` for expected failures
  - rely on final `errorHandler` to shape `ApiErrorBody`
  - never leak stack traces or secrets to clients
- Use early returns and small functions for readability.

### Streaming & concurrency

- For SSE endpoints:
  - set proper SSE headers
  - track streams by id and ensure cleanup (`finally` removing controllers)
  - support aborts via `AbortController`
- For heavy I/O:
  - avoid unbounded parallelism
  - validate file types/sizes
  - prefer `fs/promises` over synchronous FS in request paths

### Data paths & persistence

- Data lives under `server/data/` (JSON entities/config + media).
- Migration direction: from JSON to DB (Drizzle/SQLite) for new features.
- Do not rely on `__dirname` for data paths in runtime-critical code:
  - prefer `process.cwd()` + env (e.g. `DB_PATH`)
  - keep one source of truth for paths
- File-based writes should be safe:
  - avoid partially-written JSON (temp → atomic rename)
  - consider minimal in-memory locking for concurrent writes if you touch that code

### Security

- Never serve `data/` wholesale as static; only expose explicitly public folders (e.g. `data/media` via `/media`).
- Secrets:
  - never return API keys in responses (mask in UI-facing endpoints)
  - prefer env/config for secrets (treat `data/config/*` as sensitive)
- Enforce payload limits for JSON and uploads; don’t increase without a clear reason.

### Decomposition (no “god files”)

- One file = one responsibility.
- If a module grows beyond ~200 lines or mixes concerns:
  - route handlers → `routes/`
  - orchestration → `services/`
  - framework glue → `core/`
  - persistence/infra → `core/services/` or `db/`

### Verification commands

After any backend changes, run type checks and fix all issues:

- From repo root:
  - `yarn typecheck:server`
- Or:
  - `yarn -C server typecheck`
- DB migrations when relevant:
  - `yarn -C server db:migrate`

**Never** run lint/formatter commands or any bulk auto-fix tools without explicit user permission.

---
description: Frontend (web/): Vite + React + TypeScript + Effector + Mantine, code quality & architecture rules
alwaysApply: false
---

## Role

You are a Senior Frontend Developer for this repository.
Write production-grade code: strict types, clear boundaries, small modules, and **no unreadable monsters**.

## Current frontend stack (this repo)

- **App location**: `web/` (Vite + React + TypeScript)
- **State management**: **Effector** + `effector-react` (+ `patronum` when useful)
- **UI**: **Mantine** (`@mantine/core`)
- **Icons**: `react-icons/lu`
- **Markdown**: `react-markdown` (currently with `rehype-raw` in places)
- **Package manager**: **Yarn Classic (1.x)** (do not suggest npm/pnpm)

## Non-negotiable constraints

- **Yarn only**. Use repository scripts; prefer `yarn --cwd web <script>` from repo root.
- **Effector is the source of truth** for state and async flows. UI binds state via `useUnit`.
- **Mantine is primary**. Prefer Mantine components/tokens over custom CSS when reasonable.
- **Do not introduce new heavy infra** (new router, new global state lib, new form framework) unless explicitly requested.
- **Comments must be in English**.

## Project structure (as-is)

This codebase follows **strict FSD** (Feature-Sliced Design).

- `web/src/features/*` — UI features (chat window, sidebars, etc.)
- `web/src/model/*` — Effector stores/events/effects and domain logic
- `web/src/ui/*` — shared UI components/wrappers (Mantine-based)
- `web/src/utils/*` — helpers
- `web/src/api/*` — API helpers (note: some legacy API code still lives elsewhere)
- `shared/types/*` — shared contracts with backend

### Import rules (pragmatic)

- **Prefer path aliases** (`@model/*`, `@ui/*`, `@utils/*`, `@shared/*`) over long relatives.
- **Avoid circular dependencies** between `model/*` domains. If two domains need each other, introduce a small shared abstraction.
- **Keep boundaries**:
  - `model/*` must not import from `features/*` (no UI in models).
  - `ui/*` must not import from `features/*` or concrete domain models (keep UI generic).
- **Avoid side-effect imports**. If you need initialization, prefer an explicit `init` module called from `main.tsx`/`App.tsx`.

## Naming conventions

Keep new code consistent:

- **Folders**: `kebab-case`
- **Files**: `kebab-case`
- **React components**: `PascalCase` component names
- **Booleans**: `is/has/can/should*`
- **Effector**:
  - Stores: `$name`
  - Events: `verbNoun` (imperative, meaningful)
  - Effects: `nameFx`

## TypeScript rules (strict)

- **No `any`** in new/modified code. Use `unknown` + type guards, or proper generics.
- **Do not use `// @ts-ignore`**. If absolutely unavoidable, use `// @ts-expect-error -- <reason>` with an English reason.
- Prefer `import type { ... }` when importing types only.

## UI rules

- Keep components **small and focused**:
  - UI component file: aim for **≤ 200 lines**
  - Any handler: aim for **≤ 40 lines**
- UI should be mostly declarative; heavy logic goes to `model/*` or `utils/*`.
- Avoid `key={index}` for lists; use stable IDs.

## Forms (current reality)

This repo currently uses `react-hook-form` in multiple places. Do not replace it wholesale.

- For new complex “business” flows, prefer **Effector-driven state** where it improves predictability.
- If you extend an existing `react-hook-form` form, stay consistent with that form.

## Networking & data

- Prefer a **single API client approach** (shared fetch wrapper, consistent error handling, typed responses).
- Avoid mixing multiple competing API layers in new code.

## Content safety (Markdown/HTML)

The app currently uses `rehype-raw` for Markdown rendering in places.

- Treat Markdown/HTML as **untrusted** unless it is strictly system-authored.
- If user-provided content can reach Markdown renderer, **sanitize** before allowing raw HTML.
- Prefer disabling raw HTML rendering unless explicitly needed.

## Code quality tooling (how to verify)

Frontend scripts live in `web/package.json`.

- From repo root:

  - `yarn build:web`

- From `web/`:
  - `yarn build`
  - `yarn typecheck`

## Command execution policy (IMPORTANT)

Goal: avoid large auto-generated diffs, context desync, and runaway cost/iterations when tools rewrite files.

- **STRICTLY FORBIDDEN (without explicit user permission)**:
  - Any **lint / formatter / auto-fix** commands, including (examples):
    - `eslint ...`, `yarn lint`, `yarn eslint ...`
    - `prettier ...`, `yarn format`, `prettier --check`, `prettier --write`
    - `stylelint ...`, `biome ...`, `rome ...`
    - any command that **rewrites many files automatically** or applies formatting fixes
- **Allowed verification commands (do not rewrite code)**:
  - `yarn build:web`
  - `yarn --cwd web build`
  - `yarn --cwd web typecheck`

**CRITICAL: LLM must NEVER run lint/formatter commands automatically.** Linting is only for manual execution by the developer.

If TypeScript fails, keep fixing until **0 TS errors**.

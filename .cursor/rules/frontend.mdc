---
description: Frontend (web/): Vite + React + TypeScript + Effector + Mantine — code & architecture protocol
alwaysApply: false
---

## Frontend task protocol

When editing or creating frontend code under `web/`, follow these **non‑negotiable rules**.

### Output format

- Prefer returning **only**:
  - a single TypeScript/TSX code block, or
  - a minimal diff (explained in plain English + code block)
- Do not add conversational fluff.
- If clarification is needed, ask short, targeted questions **before** generating large code blocks.

### Stack (must respect)

- App location: `web/` (Vite + React + TypeScript)
- State management: **Effector** + `effector-react` (+ `patronum` when useful)
- UI: **Mantine** (`@mantine/core`)
- Icons: `react-icons/lu`
- Markdown: `react-markdown` (with `rehype-raw` in some places)
- Package manager: **Yarn Classic (1.x)** — do not suggest npm/pnpm

### Architecture & boundaries

- Project uses **strict Feature-Sliced Design (FSD)**:
  - `web/src/features/*` — UI features (chat window, sidebars, etc.)
  - `web/src/model/*` — Effector stores/events/effects and domain logic
  - `web/src/ui/*` — shared UI components / wrappers (Mantine-based)
  - `web/src/utils/*` — helpers
  - `web/src/api/*` — API helpers (some legacy code exists elsewhere)
  - `shared/types/*` — shared contracts with backend
- Import rules:
  - Prefer path aliases: `@model/*`, `@ui/*`, `@utils/*`, `@shared/*`
  - Avoid circular dependencies between `model/*` domains
  - `model/*` must not import from `features/*`
  - `ui/*` must not import from `features/*` or concrete domain models
  - Avoid side-effect imports; initialization via explicit `init` modules from `main.tsx` / `App.tsx`

### Code style and TypeScript

- No new `any` in new or modified code.
- Avoid `// @ts-ignore`. If unavoidable, use `// @ts-expect-error -- <reason>` (English reason required).
- Prefer `import type { ... }` for type-only imports.
- Comments in code must be in **English**.

### UI and component rules

- Components should be small and focused:
  - component file size target: ≤ 200 lines
  - any handler: ≤ 40 lines
- Heavy logic lives in `model/*` or `utils/*`, not in React components.
- Avoid `key={index}` for lists; prefer stable IDs.
- Prefer Mantine components/tokens over custom CSS when reasonable.

### State and forms

- **Effector is the source of truth** for state and async flows; UI binds state via `useUnit`.
- Existing forms: `react-hook-form` is used in places — do not replace wholesale.
- For new complex business flows:
  - prefer Effector-driven state where it improves predictability
  - when extending existing `react-hook-form` forms, follow local style

### Networking & data

- Prefer a single API client approach (shared fetch wrapper, consistent error handling, typed responses).
- Avoid introducing parallel API layers in new code.

### Content safety (Markdown/HTML)

- Treat Markdown/HTML as untrusted unless strictly system-authored.
- If user-provided content is rendered with Markdown, sanitize before allowing raw HTML.
- Prefer disabling raw HTML where possible; only enable when explicitly required.

### Verification commands (do not auto‑run more)

From repo root:

- Allowed:
  - `yarn build:web`
- From `web/`:
  - `yarn build`
  - `yarn typecheck`

**Never** run lint/formatter or any command that rewrites many files automatically without explicit user permission (e.g. `eslint`, `prettier`, `yarn lint`, `yarn format`).
Fix TypeScript errors until there are **0 TS errors** before considering the task complete.

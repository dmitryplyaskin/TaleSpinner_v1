# TaleSpinner server — архитектурный обзор (2026-01-17)

Контекст: backend для работы с LLM (OpenRouter/OpenAI SDK) и генерации/ведения историй. Сейчас persistence сделан через JSON-файлы в `server/data/`, планируется переезд на полноценную БД. Проект был “реанимирован” после апдейта зависимостей.

Ниже — сильные стороны, проблемы (с приоритетами), архитектурные риски и рекомендации “для большей строгости” (типизация, слойность, валидация, ошибки, безопасность), а также дорожная карта для миграции на БД.

---

## Быстрая карта текущей архитектуры

- **Entrypoint**: `src/index.ts`
  - подключает middleware (`cors`, `morgan`, `express.json`)
  - сервит статику (`public`, `data`) + отдельный `/media` роутер
  - регистрирует роуты **двумя стилями одновременно**:
    - “старые” роуты: `src/routes/*`
    - “новые” роуты через фабрики: `src/api/*` + `src/core/factories/*`
- **Файловая “БД”**
  - сущности (CRUD) через `BaseService<T extends BaseEntity>`: файлы `data/<dir>/<id>.json`
  - конфиги через `ConfigService<T extends BaseConfig>`: файлы `data/config/*.json`
- **LLM**
  - `OpenRouterService` читает/пишет `data/config/openrouter.json`, делает стриминг, есть `routes/generate-routes.ts` (SSE).
- **Файлы/медиа**
  - `FileService` хранит `data/files/*`
  - `/media/*` сервится из `data/media/*`
  - есть upload png/json карточек + картинки в `data/media/images/...`

---

## Сильные стороны (что уже хорошо)

- **TypeScript `strict: true`** включён на уровне `server/tsconfig.json` — отличная база.
- **Попытка унификации API**:
  - `asyncHandler` для централизованной обработки async-ошибок
  - `RouteFactory` + `GeneralController`/`CrudController`/`ConfigController` как каркас для однотипных CRUD+settings эндпоинтов
- **Явное разделение “config” и “entities”**:
  - `ConfigService` для `data/config/*.json`
  - `BaseService` для сущностей в отдельных директориях
- **SSE-стриминг** уже реализован (генерация по токенам).
- **Наличие `AbortController`** для остановки стримов — правильный UX/контроль ресурсов.

---

## Проблемы и риски (по приоритетам)

### Критично (исправить в первую очередь)

1. **Утечка секретов через статику**

- В `src/index.ts` есть `app.use(express.static("data"))`.
- Это потенциально делает публично доступными файлы из `data/config/*` (включая `openrouter.json` с `apiKey`) и вообще любые JSON-данные.
- Дополнительно есть `GET /config/openrouter`, который возвращает конфиг целиком (в т.ч. ключ).

**Рекомендация**: никогда не сервить целиком `data/`. Сервить только строго выделенные публичные каталоги (например `data/media/*`) и никогда не отдавать `config` наружу. API ключ — только через env/секреты, не через публичное API.

2. **Прод-сборка, вероятно, не запустится из-за path aliases**

- В `tsconfig.json` настроены алиасы (`@core/*`, `@services/*`, ...).
- `tsc` **не переписывает** алиасы в относительные пути — в `dist` останутся `require("@core/...")`.
- `server/package.json` запускает прод через `node dist/src/index.js` без `-r tsconfig-paths/register`.

**Рекомендация** (выбрать один путь):

- либо убрать алиасы и перейти на относительные импорты,
- либо добавить шаг после `tsc` (например `tsc-alias`) и/или настроить runtime-resolver (не самый лучший путь для прод),
- либо собирать через bundler (esbuild/tsup) и “разруливать” алиасы на этапе сборки.

3. **Пути к данным зависят от `__dirname` и ломаются в `dist`**

- `DATA_PATH = path.join(__dirname, "../data/")` (в `src/const.ts`).
- В runtime через `ts-node` это будет `server/src -> server/data` (ок),
  но в `dist` это будет `server/dist/src -> server/dist/data` (почти наверняка **не то**).
- Параллельно часть кода использует `process.cwd()` (например, `FileService`, static `/media`), т.е. **две разные “точки отсчёта”**.

**Рекомендация**: выбрать единый источник правды для путей (`DATA_DIR` из env или `process.cwd()/data`), и использовать его везде. Для библиотечного кода (сервисы) — прокидывать `dataDir` как зависимость.

4. **`ConfigService`/`BaseService` делают async-init без `await`**

- В конструкторах вызываются `ensureDirectory()`/`ensureConfigDirectory()` без ожидания.
- Это даёт гонки: первый запрос может прийти раньше, чем директория создана.

**Рекомендация**: либо сделать явную фазу `init()` и вызывать её при старте сервера, либо создавать директории синхронно при старте (один раз), либо гарантировать `await` (но тогда конструктор не подойдёт — нужен фабричный метод/инициализация сверху).

5. **API “settings” частично возвращает `void`**

- `ConfigService.saveConfig()` возвращает `Promise<void>`.
- `ConfigController.setSettings` возвращает `{ data: settings }`, где `settings` — `void`.
- В “старых” роутерах (`routes/settings-routes.ts`) тоже `res.json(settings)` после `saveConfig(...)`.

**Рекомендация**: либо возвращать сохранённый объект (`return config`), либо после записи делать `getConfig()` и возвращать актуальные данные.

---

### Высокий приоритет

1. **Два параллельных API-стиля (раздвоение архитектуры)**

- Есть `src/routes/*` с ручным `try/catch`.
- Есть `src/api/*` через фабрики/контроллеры и `asyncHandler`.

Риск: дублирование логики, разные форматы ответов, разные правила ошибок, разные пути.

**Рекомендация**: выбрать один стиль (скорее “новый” через контроллеры/фабрики) и постепенно мигрировать старые роуты в него.

2. **Нет единого формата ответа и нет контрактов DTO**

- Где-то ответ — “голый JSON”, где-то `{ data: ... }`, где-то ожидаются `headers/raw` поля, но `asyncHandler` их не применяет.

**Рекомендация**: ввести единый `ApiResponse<T>` и поддержку:

- `data`
- `meta`
- `error`
- опционально `raw/body` + `status` + `headers` (если реально нужно отдавать бинарь)

3. **`asyncHandler` и `errorHandler` не доведены до “сквозного” использования**

- `errorHandler` написан, но в `src/index.ts` не подключён как финальный middleware.
- Старые роуты ловят ошибки вручную, новые — кидают `Error`.
- Плюс есть **две несовместимые модели Logger** (`@core/types/common` и `core/middleware/async-handler`).

**Рекомендация**: один Error-пайплайн:

- `asyncHandler` оборачивает все роуты,
- все ошибки — `HttpError` (или аналоги),
- финальный `app.use(errorHandler(logger))`,
- один общий `Logger` тип.

4. **Валидации входных данных практически нет**

- Сейчас почти везде `req.body as Type` без проверок.
- Это опасно даже на файловой “БД” (можно записать невалидные JSON и сломать чтение/сортировку).

**Рекомендация**: runtime-валидация DTO (например, zod) на boundary (controllers/routes). Типы из `@shared` должны иметь соответствующие схемы.

5. **Файловая “БД” без атомарности и без блокировок**

- `writeFile` напрямую по целевому пути.
- При падении/параллельных операциях можно получить частично записанный JSON.

**Рекомендация**: атомарная запись (write temp → rename), а на запись/удаление — простой mutex на уровень файла/директории (хотя бы in-memory) до миграции на настоящую БД.

6. **Безопасность LLM/генерации**

- Нет rate limit / ограничения по пользователю / учёта токенов / таймаутов.
- Нет авторизации вообще (по коду).

**Рекомендация**: минимально — лимиты на запросы и размер payload, таймауты, ограничения concurrent-streams, хотя бы простая auth (token) для приватного сервиса.

---

### Средний приоритет

- **Смешение sync и async FS** (`OpenRouterService` — sync `fs.*Sync`, остальные — `fs/promises`).
- **`@ts-ignore` и `any` вокруг OpenAI/OpenRouter** (теряется строгость, хуже refactor safety).
- **Зависимости**:
  - в `server/package.json` лежат `@types/react`/`@types/react-dom` (скорее всего случайно, для backend это мусор и может запутывать).
- **Логирование**
  - `console.log(filePath)` в `static.api.ts` будет спамить.
  - нет request-id/correlation-id, уровней, структурированных логов.

---

## Рекомендации по “большей строгости” (практические шаги)

### 1) Строгие границы слоёв

Предлагаемая “чистая” схема:

- `routes`/`controllers` — **только HTTP**: валидация входа, маппинг DTO ↔ домен, статус-коды.
- `services` (use-cases) — бизнес-логика: “создать чат”, “дублировать”, “сгенерировать”.
- `repositories` — доступ к данным (файлы сейчас, БД позже).
- `providers` — внешние интеграции (OpenRouter/OpenAI, файловое хранилище медиа).

Главный принцип: **controllers не должны знать про JSON-файлы**, а services не должны знать про Express.

### 2) Единый контракт ошибок

- Ввести `HttpError`/`DomainError` набор (400/404/409/422/500).
- Все “ожидаемые” ошибки — это `HttpError(400|404|...)`.
- Все остальные — 500 + лог.
- Подключить `errorHandler` как последний middleware.

### 3) Runtime-валидация DTO

- На каждый входящий body/query/params — схема (zod).
- Из схем генерировать TS-типы (или наоборот, но чтобы не расходились).
- Это даст реальную “строгость” (а не только compile-time).

### 4) Строже TypeScript (поверх `strict`)

Рассмотреть включение (постепенно, с фиксом мест):

- `noUncheckedIndexedAccess`
- `exactOptionalPropertyTypes`
- `noImplicitOverride`
- `useUnknownInCatchVariables`
- `noPropertyAccessFromIndexSignature`

Цель: убрать `any`, `@ts-ignore`, неявные `unknown`/`void`-ответы и т.д.

### 5) Строгое API-форматирование ответа

Сделать единый тип, например:

- `ApiOk<T> = { data: T; meta?: ... }`
- `ApiError = { error: { code: string; message: string; details?: unknown } }`

И добиться, чтобы **все** endpoints были предсказуемыми.

### 6) Конфигурация и секреты

- Ключи (OpenRouter API key) — только env/секреты.
- `data/config/*.json` — только для “не секретных” настроек UI (selectedId/enabled и т.п.).
- Добавить валидатор env (zod/envalid) при старте.

### 7) Подготовка к миграции на БД (без боли)

Сейчас самое важное — **ввести репозитории как интерфейсы**, и оставить файловую реализацию как одну из.

Например:

- `ChatRepository` (getById, list, create, update, delete)
- `ConfigRepository` (get/set)

Тогда переезд на Postgres/SQLite (через Prisma/Drizzle/TypeORM) будет “заменой реализации”, а не переписыванием всего сервера.

---

## Конкретные “быстрые победы” (1–2 вечера)

- Убрать `express.static("data")`, оставить только `/media` на `data/media`.
- Перестать отдавать `apiKey` наружу (убрать/изменить `GET /config/openrouter`).
- Починить `ConfigService.saveConfig`/контроллеры так, чтобы API возвращало объект, а не `void`.
- Привести `DATA_PATH` к единому источнику (`process.cwd()` или env `DATA_DIR`) и использовать везде.
- Убедиться, что прод-`start` реально работает с алиасами (починить сборку/импорты).
- Подключить `errorHandler` глобально и убрать ручные `try/catch` в роутерах (через миграцию на `asyncHandler`).

---

## Что бы я сделал “следующим слоем” (если есть время)

- Ввести `zod`-схемы для основных DTO (generate/settings/chat/entities).
- Ввести `pino` (или аналог) + request-id middleware.
- Ограничения на генерацию: rate limit, max concurrent streams, лимит на размер `messages`, серверные таймауты.
- Тесты на репозитории (файловую реализацию) + e2e на пару критических роутов.

---

## Примечания/наблюдения по конкретным узлам (коротко)

- `RouteFactory` сейчас создаёт `/.../:id/duplicate`, но `CrudController.duplicate` берёт данные из `req.body` и игнорирует `:id` — это либо баг, либо несогласованный контракт.
- В `api/files/controllers.ts` возвращаются `headers`/`raw`, но текущий `asyncHandler` это не применяет (он просто делает `res.json(result)`), т.е. бинарные ответы/заголовки фактически не работают так, как ожидается.
- `OpenRouterService` хранит ключ в JSON и читает его sync — это одновременно и security, и производительность/стиль.
- В `server/` одновременно есть `nodemon.json` (корректный запуск с `tsconfig-paths/register`) и `nodemonConfig` в `package.json` (который указывает на `./src/index.js`). Лучше оставить один источник конфигурации (обычно `nodemon.json`) и удалить/починить дублирующий, чтобы не ловить “магические” расхождения между окружениями.

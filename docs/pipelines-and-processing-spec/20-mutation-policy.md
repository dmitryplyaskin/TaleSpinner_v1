# TaleSpinner — Pipelines + Pre/Post Processing Spec (v0.1) — Mutation policy

> Статус: **draft** для обсуждения.  
> Цель: зафиксировать архитектуру пайплайнов и пре/постпроцессинга, совместимую с текущим chat-core флоу, чтобы дальше согласовать API и начать реализацию.

## Модель влияния: два контура мутаций

Чтобы пайплайны были и мощными, и объяснимыми, вводим разделение:

### A) Prompt-time (без изменения БД истории)

Шаги могут:

- выбирать/триммить сообщения для prompt,
- преобразовывать контент для prompt (нормализация, “свернуть” старое в summary **только в prompt**),
- добавлять system/developer инструкции,
- (v2+) добавлять RAG/tool результаты как prompt-time инъекции,
- добавлять prompt-only инъекции (augmentation и т.п.) для улучшения качества **без изменения** канонической истории.

Но при этом:

- исходные `chat_messages`/`message_variants` в БД не меняются.

### B) Canonical-state (сохранение результата текущего хода)

Шаги могут:

- формировать итоговый `message_variants.promptText`,
- формировать итоговый `message_variants.blocksJson` (опционально),
- проставлять метаданные (citations, safety flags, structured output).

### C) Исторические трансформации (не по умолчанию)

Отдельный класс операций, которые действительно изменяют историю (например: заменить пачку старых сообщений summary-эквивалентом).

Рекомендация v1:

- либо **не включать**,
- либо реализовывать как добавление нового “summary message” без удаления старого,
- либо делать это отдельным, явно вызываемым action/endpoint (не часть обычной отправки сообщения).

## Политика мутаций (Mutation Policy)

### Зачем

Без политики мутаций пайплайн может стать “магией”, которая:

- ломает воспроизводимость prompt,
- непредсказуемо меняет историю,
- делает UI/варианты несогласованными.

### Базовое правило v1

По умолчанию разрешено:

- Prompt-time мутации PromptDraft,
- Canonical-state мутации текущего assistant variant/message,
- Логирование (step input/output, generation params/snapshot).

Запрещено по умолчанию:

- Мутации сообщений, не относящихся к текущему ходу:
  - по умолчанию нельзя менять прошлые `chat_messages`/variants
  - в рамках текущего хода допускается `message_transform` только для **текущего `userMessageId`**, если явно разрешено policy
- Удаление/перезапись history,
- Изменение selected variant “задним числом” у прошлых сообщений.

### Разрешённые “write targets” (v1)

Пайплайн может писать только в:

- `pipeline_runs`, `pipeline_step_runs` (лог процесса)
- `llm_generations` (статус, params, snapshot, usage)
- **сообщения текущего хода (turn)**:
  - текущие `message_variants` (assistantVariantId)
  - текущий `chat_messages` (assistantMessageId) — как кэш выбранного варианта
  - текущий `chat_messages` (userMessageId) и его variants — **только для текущего входа**, если шагу разрешено `message_transform`
- **`pipeline_artifacts`** (см. ниже) — если шагу разрешено `artifact_write` / `state_write`

Дополнение (важно для безопасности и детерминизма v1):

- **Single-writer per persisted `tag`**: шаг может писать только в те persisted-артефакты `art.<tag>`, которые принадлежат его пайплайну (writer-ownership).
- Попытка записать в чужой `tag` должна приводить к **ошибке policy** (runtime guard), даже если конфиг был провалидирован при сохранении `PipelineProfile`.

Запрещено по умолчанию (остается как guardrail v1):

- изменять **прошлые** `chat_messages`/variants (не относящиеся к текущему ходу) — только через отдельную, явно оформленную “историческую трансформацию”.


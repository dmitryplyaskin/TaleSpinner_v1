# TaleSpinner — Pipelines + Pre/Post Processing Spec (v0.1) — Future & open questions

> Статус: **draft** для обсуждения.  
> Цель: зафиксировать архитектуру пайплайнов и пре/постпроцессинга, совместимую с текущим chat-core флоу, чтобы дальше согласовать API и начать реализацию.

## Версии и расширения (на будущее)

### v2+: DAG и многошаговая агентика

Возможные расширения:

- шаги как граф зависимостей (parallel execution),
- tool↔LLM loops,
- conditional branching (if/else) внутри pipeline definition,
- “memory” сущности (summary/notes) как отдельный тип сообщений или отдельная таблица.
- разграничение доступа (ACL) к persisted-артефактам **между пайплайнами** (если появятся плагины/мультиюзер/недоверенный код).
- “настоящая” идемпотентность API (например `Idempotency-Key`/`requestId`) и политика безопасных авто‑ретраев.

### v2+: Исторические трансформации

Если появится “compaction/summarize history”, то:

- оформляется как отдельный stepType (например `history_compaction`),
- имеет строгую политику: что меняется, где хранится “до/после”,
- и обязательно логируется как отдельный action/run.

## Открытые вопросы (для согласования перед API)

### Уже договорились (фиксируем для v1)

- **PipelineProfile** — сохраняемый набор активных пайплайнов (конфиг), который:
  - может быть выбран глобально,
  - может быть закреплён как override для `entityProfile` и/или конкретного `chat`.
- **Session** для persisted-артефактов в v1 — **chat-scoped** (ветки откладываем ради упрощения реализации).
- **Tags**:
  - `art.<tag>` уникален в пределах (`ownerId`, `sessionId`=chatId),
  - один writer на persisted `tag` (пайплайн не пишет в чужой тег),
  - основная валидация коллизий — при сохранении/активации `PipelineProfile`,
  - runtime-guard на запись остаётся как защита данных.
- **Хранение артефактов**: модель **Latest + History** (текущее значение всегда доступно; история — по retention).
- **Session snapshot**: v1 — **debug-only** (возможный откат рассматриваем как v2+).
- **Deps-контракт пайплайна**: в v1 **не вводим** отдельный декларативный deps-контракт (это опциональная оптимизация реализации или тема v2+).
- **Конфликты обновления `art.<tag>`**: v1 минимум — optimistic concurrency с `basedOnVersion` и **reject** при mismatch (без auto-retry/merge).
- **Idempotency/ретраи**: v1 минимум — дедупликация `PipelineRun` по ключам turn-а (без авто‑ретраев; повторы через `regenerate`).

1. Делаем ли пайплайны строго “один ход” (user→assistant) в v1, или закладываем многошаговые сценарии сразу?
2. Где хранится pipeline selection: на уровне chat? entityProfile? global? (и как наследуется)
3. Хотим ли мы v1 “tool step” как часть pipeline (хотя бы до LLM), или откладываем?
4. Нужны ли UI-события по шагам (`pipeline.step.*`) уже в v1?
5. Нужен ли `promptSnapshotJson` в v1 (с redaction), или достаточно `pipeline_step_runs` логов?

### Оставшиеся вопросы (на следующую итерацию обсуждения)

6. Нужен ли v2+ `Idempotency-Key/requestId` на уровне API и какие авто‑ретраи допустимы без дублей/гонок?


# v2 — Artifacts (артефакты)

Этот документ фиксирует **что такое Artifact в v2**, какие есть **инварианты** (адресация, запись, уникальность), чем отличаются **persisted** и **run_only** артефакты, и как они связаны с `OperationProfileSession`.

Связанные документы:

- Термины: [`00-terminology.md`](./00-terminology.md)
- Operation (контракт и эффекты): [`10-operation.md`](./10-operation.md)
- OperationProfile (хранилище операций + save-time validation): [`20-operation-profile.md`](./20-operation-profile.md)
- Run: [`30-run.md`](./30-run.md)

## 1) Что такое Artifact (в одном абзаце)

**Artifact** — это результат работы операций, который живёт **рядом с историей сообщений**, но **не является** сообщением в `ChatHistory`.

Артефакты нужны, чтобы:

- хранить состояние/память и показывать её в UI (панели, ленты);
- давать main LLM дополнительный контекст (через включение в `effective prompt`);
- передавать промежуточные данные между операциями (особенно внутри одного `Run`).

## 2) Адресация: `art.<tag>`

Каждый артефакт адресуется как **`art.<tag>`** и имеет минимум `value`.

Инварианты:

- `tag` должен быть **уникальным в рамках одного `OperationProfile`** (коллизия — ошибка конфигурации профиля).
- артефакт — это **write target**: операции читают и (при успехе) пишут артефакты как отдельный слой данных, не переписывая прошлую `ChatHistory`.
- чтение значения артефакта выполняется через **`art.<tag>.value`** (и для `persisted`, и для `run_only`).

## 3) Две независимые оси артефакта: `usage` и `semantics`

### 3.1 `usage` (где используется / кто видит)

- `prompt_only` — участвует только в `effective prompt`
- `ui_only` — показывается только в UI
- `prompt+ui` — и участвует в prompt, и показывается в UI
- `internal` — не участвует в prompt и не показывается в UI (служебный результат)

### 3.2 `semantics` (что это по смыслу)

Нормативный минимальный набор (расширяемый строкой):

- `state` — состояние/память мира (погода/время/локация/статы и т.п.)
- `log/feed` — лента/журнал событий (timeline)
- `lore/memory` — лор/память персонажей/мира
- `intermediate` — промежуточный результат (кэш/guard-флаги/tool-выходы и т.п.)

## 4) Persisted vs run_only

### 4.1 `persisted`

**persisted** артефакт:

- живёт **между** `Run` (переживает много запусков),
- хранится в `OperationProfileSession`,
- может иметь историю версий `history[]` (по retention политике).

Типичные примеры:

- `art.world_state`: `usage="prompt+ui"`, `semantics="state"`
- `art.lore`: `usage="prompt_only"` или `prompt+ui`, `semantics="lore/memory"`

### 4.2 `run_only`

**run_only** артефакт:

- существует только **в рамках одного `Run`**,
- не сохраняется между ходами,
- **не имеет** `history[]` (история имеет смысл только для persisted).
- хранится в **run-local** хранилище и **недоступен** вне текущего `Run`.

Типичные примеры:

- `art.is_combat`: `usage="internal"`, `semantics="intermediate"` (guard-флаг)
- `art.augmentation_notes`: `usage="prompt_only"`, `semantics="intermediate"` (одноразовый контекст для main LLM)

Чтение:

- значение `run_only` артефакта читается как **`art.<tag>.value`** (как и у persisted).

Важно про зависимости:

- если операция читает **артефакт, который должна создать/обновить другая операция в этом же `Run`** (не важно, `persisted` это или `run_only`) и хочет гарантировать, что значение уже доступно, она обязана явно указать зависимость через `dependsOn` (см. `10-operation.md`). Иначе (при параллельном исполнении) нельзя полагаться на порядок и факт готовности данных.

## 5) Правила записи (write policy)

### 5.1 Single-writer per `tag` (на уровне профиля)

В v2 действует правило: **один `tag` — один writer** в рамках `OperationProfile`.

Практически:

- если две операции в одном профиле потенциально пишут в один и тот же `art.<tag>` — профиль невалиден и не должен сохраняться (save-time validation).

### 5.2 Одна операция пишет только в один `art.<tag>`

Инвариант v2: **одна операция может писать (создавать/обновлять) только в один `art.<tag>`**.

Если нужно обновить несколько артефактов — это должно быть несколько операций.

### 5.3 Когда эффекты реально применяются

С точки зрения v2 модели исполнения (см. `10-operation.md`):

- операция может исполняться (execute) как угодно,
- но запись/обновление артефакта считается применённой **только при** `OperationResult.status="done"` (commit‑правило).

## 6) История и retention (только для persisted)

Persisted‑артефакт может хранить:

- `value` — актуальное значение,
- `history[]` — предыдущие значения (размер/окно определяется retention политикой).

v2 фиксирует только принцип:

- история ограничена (по количеству версий, TTL или обоим),
- UI и prompt обычно работают с “материализованным” представлением (чаще всего `value`, а не вся история).

Конкретная форма `retention` и формат версий/диффов могут быть уточнены позже как отдельный раздел/документ.

## 7) Связь с `OperationProfileSession`

Persisted‑артефакты живут внутри **`OperationProfileSession`**.

Ключевые свойства:

- `OperationProfileSession` выбирается/создаётся по ключу `chatId + branchId + operationProfileRef + operationProfileSessionId`.
- смена `operationProfileSessionId` (reset) означает: последующие `Run` начинают работать с **новой** сессией и **не видят** старые persisted‑значения (они остаются в старой сессии по политике продукта).

## 8) Артефакты и prompt (PromptInclusion)

Артефакт может участвовать в `effective prompt`:

- либо напрямую как `usage="prompt_only"`/`prompt+ui`,
- либо через явное правило включения (**PromptInclusion**) для persisted‑артефактов.

Нормативная идея v2: включение артефактов в prompt должно быть **явным и воспроизводимым** (чтобы можно было объяснить “что реально ушло в prompt”).

Детальная схема `PromptInclusion` и точный алгоритм prompt building описываются отдельно; в v2 core достаточно фиксировать, что:

- включение — это политика, а не “магия”;
- артефакт может включаться как system‑вставка и/или как синтетическое сообщение (в т.ч. “после последнего user”).

См. термин `PromptInclusion` в [`00-terminology.md`](./00-terminology.md).

## 9) UI‑проекция артефактов (не равно retention)

Артефакт — это **данные**. То, как они отображаются, — UI‑проекция.

Практическая договорённость v2:

- панели состояния (`semantics="state"`) обычно показывают **только `value`** (latest),
- ленты (`semantics="log/feed"`) могут показывать историю как timeline,
- но это UI‑решение и не должно смешиваться с правилами хранения.

## 10) Примеры

### 10.1 `art.world_state` (persisted, state)

- `tag`: `world_state`
- `usage`: `prompt+ui`
- `semantics`: `state`
- живёт в `OperationProfileSession` и обновляется post‑операцией после main LLM

### 10.2 `art.is_combat` (run_only, guard)

- `tag`: `is_combat`
- `usage`: `internal`
- `semantics`: `intermediate`
- вычисляется в `before_main_llm` и используется зависимыми операциями через `dependsOn`

### 10.3 `art.augmentation_notes` (run_only, prompt-only)

- `tag`: `augmentation_notes`
- `usage`: `prompt_only`
- `semantics`: `intermediate`
- создаётся в `before_main_llm` и включается в prompt как синтетическое сообщение


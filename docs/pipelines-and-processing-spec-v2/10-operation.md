# v2 — Operation (контракт и модель исполнения)

Этот документ фиксирует, **что такое Operation**, как она исполняется в рамках `Run`, и какой у неё **контракт** (входы/выходы/эффекты/ошибки/логирование).

> Принцип v2: **Operation — это blackbox-единица исполнения**.  
> Она может делать сколько угодно внутренней работы (aux LLM, вычисления, интеграции), но наружу отдаёт только **явные эффекты**.

## 1) Что такое Operation (в одном абзаце)

**Operation** — это **одно исполняемое действие** (“сделай X”), которое запускается в одном из **двух хуков**:

- `before_main_llm` — до main LLM
- `after_main_llm` — после main LLM

Operation получает **контекст текущего запуска (`Run`)** и возвращает **набор эффектов** в один или несколько слоёв:

- **Prompt-time**: влияет на effective prompt *только для этого* main LLM вызова
- **Turn canonicalization**: меняет канон *текущего хода* (variants/selected, blocks/meta и т.п.), не переписывая прошлое
- **Artifacts / Memory**: читает/пишет `art.<tag>` (persisted или run_only)

Operation **не “встраивается внутрь” main LLM** и не управляет его стримингом/flush’ем. Main LLM остаётся отдельным процессом, а Operation влияет на него только через подготовленные данные и канонизацию результата.

## 2) Зачем v2 убирает `pre/post` и “шаги”

В v2 мы сознательно **не описываем** систему как “пайплайны = список шагов (`pre/llm/post`)”, потому что:

- в реальности “пайплайны” были **blackbox**, а не набором настраиваемых шагов;
- `pre/post` — это **внутренняя раскладка оркестратора**, а не понятная пользователю единица настройки;
- нам нужно без переименований добавлять новые типы действий (RAG, tool, нормализации, state updates) **как до**, так и **после** main LLM.

Вместо этого v2 делает единицей конфигурации **Operation**, а точка запуска задаётся явно через **Hook**.

## 3) Место Operation в Run

`Run` запускается по `Trigger`:

- `generate` — новый ход
- `regenerate` — новый вариант ассистента в рамках текущего хода

Далее (минимальная модель v2):

1. Запустить операции `before_main_llm`:
   - операции **могут исполняться параллельно**,
   - но операция **не стартует**, пока все её зависимости не завершились со статусом **`done`** (см. `dependsOn`).
2. Дождаться, пока **все** операции `before_main_llm`, которые должны были запуститься в этом `Run`, завершатся в **терминальном статусе** (`done|error|aborted|skipped`).
3. Если среди `before_main_llm` есть операции с `required=true`, завершившиеся **не** `done` → `Run` считается неуспешным, и **main LLM не стартует**.
4. Исполнить **ровно один** `main LLM` вызов (используя effective prompt), только если барьер пройден.
5. Исполнить операции `after_main_llm` (так же: параллельно + ожидание зависимостей).
6. Зафиксировать итоговые статусы `Run`/`OperationRun` и применённые эффекты

## 4) Контракт Operation (минимальный)

### 4.1 OperationDefinition (что это за операция)

**OperationDefinition** — описание “что это за операция” (идентичность и диспетчеризация):

- `operationId: string` — стабильный идентификатор (например `builtin:world_state_update`)
- `name: string` — человекочитаемое имя
- `description?: string` — кратко “зачем”
- `kind: "llm" | "rag" | "tool" | "compute" | "transform" | "legacy" | string`
- `capabilities?: { ... }` — опционально: декларация того, что операция *может* делать (см. 4.4)

> Важно: v2 не требует, чтобы операция “состояла из шагов”. Её внутренняя реализация — произвольна.

### 4.2 OperationConfig (как она настроена)

**OperationConfig** — набор параметров, который определяет, *как именно* эта операция должна выполняться:

- `enabled: boolean`
- `required: boolean` — обязательна ли операция для успешного продолжения `Run`.
  - если `required=true`, то операция должна завершиться **`done`**, иначе `Run` не продолжается через барьер (для `before_main_llm`) или помечается как неуспешный (для `after_main_llm`).
  - если `required=false`, то `error/aborted/skipped` **не блокируют** продолжение `Run`.
  - важное уточнение для `after_main_llm`: `required=true` **не откатывает** уже выполненный main LLM и не “отменяет” записанный assistant variant. Это только сигнал, что Run считается **failed** (и, соответственно, UI/логика ретрая/наблюдаемость должны показывать, что пост-операции не завершились успешно).
- `hooks: ("before_main_llm" | "after_main_llm")[]` (обычно один)
- `triggers?: ("generate" | "regenerate")[]` (если не задано — оба)
- `order: number` — **обязательный** приоритет/порядок внутри hook (меньше = раньше).
  - `order` влияет не только на “порядок в списке”, но и на **очередь применения эффектов** (commit) для prompt/UI/канона хода, даже если операции исполняются параллельно.
- `dependsOn?: string[]` — список `operationId`, от которых зависит эта операция.
  - строгое правило: операция **не стартует**, пока все `dependsOn` не завершились со статусом **`done`**.
  - если операции нужно **гарантированно** прочитать результат другой операции (особенно `run_only` артефакт) — она обязана явно указать зависимость через `dependsOn`.
- `params: Record<string, unknown>` — конфигурация операции.
- `debug?: { enabled?: boolean }`

#### 4.2.1 Где живут “параметры, зависящие от kind”

В v2 все пользовательские параметры, которые влияют на **внутреннюю работу** конкретной операции, живут в `OperationConfig.params`.

Ключевое правило:

- `OperationDefinition.kind` определяет **схему** `params` (дискриминируемый контракт).
- `params` хранится как JSON, но семантически является **типизированным объектом**, зависящим от `kind`.
- Секреты (API keys) **никогда** не лежат в `params`: там только ссылки/идентификаторы провайдеров и настройки, безопасные для хранения.

`kind="llm"` (aux LLM-операции) описываем отдельно: см. [`11-operation-kind-llm.md`](./11-operation-kind-llm.md).

### 4.3 OperationContext (что операция “видит”)

**OperationContext** — вход операции (read-only источник правды):

- **Run meta**
  - `runId`, `trigger`, `hook`
  - `chatId`, `branchId`, `turnId`/`userMessageId`, `assistantVariantId?`
- **Main LLM граница**
  - если `hook=before_main_llm`: доступен “черновик” effective prompt (см. ниже)
  - если `hook=after_main_llm`: доступен результат main LLM (selected assistant variant + финальный текст/blocks/meta)
- **Artifacts**
  - read-доступ к `art.<tag>` (persisted) и к run-local данным, **но** операция не должна полагаться на наличие run-local результата другой операции без явной зависимости через `dependsOn`
- **Abort/Deadlines**
  - `abortSignal`/`deadlineMs?`
- **Policy (минимум)**
  - ограничения на эффекты: что можно писать/менять в этом хуке
  - лимиты на размер логов/снапшотов

> В v2 контекст обязан быть таким, чтобы операция могла быть “честным blackbox”: всё, что ей нужно знать о мире, приходит через контекст.

### 4.4 OperationResult (что операция возвращает)

Operation возвращает **результат исполнения** и **набор эффектов**.

Минимальная форма:

- `status: "done" | "skipped" | "error" | "aborted"`
- `required: boolean` — *эхо из `OperationConfig.required`* (чтобы по результату/логам было видно, была ли операция обязательной и почему `Run` мог продолжиться после её ошибки).
- `effects: OperationEffects`
- `debug?: OperationDebug` (bounded, безопасный)

Где `OperationEffects` делятся по слоям:

> Примечание: точная схема `OperationEffects` и детальный механизм применения эффектов (позиционирование, trimming, якоря и т.п.) будут описаны **в отдельном документе**. Здесь фиксируем минимальный набор, достаточный для согласования модели.

#### Про `status="skipped"` (важно)

`skipped` — **валидный терминальный статус**. Он означает, что операция была **осознанно пропущена** (не выполнялась или досрочно завершилась без выполнения) по правилам конфигурации/политики/условия и это **не является ошибкой**.

Правила:

- `skipped` **не коммитит эффекты**: если операция `skipped`, считаем, что она **не произвела** `effects`.
- `skipped` может возникать, например, когда:
  - операция отключена (`enabled=false`);
  - операция не применяется к текущему `trigger` (если задан `triggers[]`);
  - операция сама решила “ничего не делать” по условию (guard/condition);
  - операция не может стартовать из‑за зависимостей (см. правила зависимостей).

Рекомендуется (не обязательно на старте) фиксировать причину пропуска как `skippedReason` (например: `disabled | trigger_mismatch | condition_false | dependency_failed | policy`), чтобы дебаг был объяснимым.

##### Пример: guard → условное выполнение зависимых операций

Операция‑guard `builtin:is_combat_guard` в `before_main_llm`:

- выполняется и завершаетcя `done`,
- пишет `art.is_combat` как `run_only` boolean (`true/false`).

Зависимые операции (например `builtin:combat_rag`, `builtin:combat_dice`) задают `dependsOn=["builtin:is_combat_guard"]`, читают `art.is_combat` и:

- если `true` → выполняются и завершаются `done`,
- если `false` → возвращают `skipped` (например с `skippedReason="condition_false"`).

#### A) Prompt-time effects

Эти эффекты **меняют effective prompt только для текущего main LLM вызова** и не становятся частью истории.

Ограничение:

- prompt-time эффекты применяются **только** в `before_main_llm` (после старта main LLM менять prompt уже нельзя).

Минимальный набор эффектов (не финальный, но достаточный для старта):

##### 1) `prompt.append_after_last_user` — вставка после текущего user input

Добавляет **синтетическое prompt-only сообщение** сразу после **текущего user‑сообщения**, которое породило `Run`.

Ключевой инвариант v2: main LLM не стартует, пока `before_main_llm` завершён, поэтому “текущий user” считается всегда доступным как якорь для вставки.

##### 2) `prompt.system_update` — модификация system prompt

Меняет **system prompt** в effective prompt одним из режимов:

- `mode="prepend"` — `payload + system` (добавить *перед* текущим system)
- `mode="append"` — `system + payload` (добавить *после* текущего system)
- `mode="replace"` — `system := payload` (полностью заменить system по правилам операции)

##### 3) `prompt.insert_at_depth` — вставка “в хвост” и “на глубину”

Унифицированный эффект для:

- **вставки в хвост** (глубина = 0),
- **вставки “на глубину”** (например “вставить за N сообщений до конца”).

Форма:

- `depthFromEnd: number`
  - `0` = вставить в самый конец effective prompt (tail)
  - `-N` = вставить “на глубину” (внутрь контекста, ближе к концу)

Точный механизм позиционирования/якорей/что делать при trimming/границах будет описан отдельно, но **порядок применения** всегда детерминированный (см. commit-очередь).

Payload для сообщения:

- `role: "system" | "developer" | "user" | "assistant"`
- `content: string`
- `source?: string` (например `art.world_state`)

#### B) Turn canonicalization effects

Эти эффекты меняют **канон текущего хода**, но не переписывают прошлую историю.
Канон хода включает:

- **текущее user‑сообщение** (текущий input, который породил `Run`)
- **assistant‑ответ текущего хода** (variants/selected/blocks/meta), если он уже существует

Ограничения по хукам:

- в `before_main_llm` операция может канонизировать **только user‑часть** (потому что assistant‑ответа ещё нет)
- в `after_main_llm` операция может канонизировать **и user‑часть, и assistant‑часть**

Типовые эффекты (примеры):

- создать/обновить variant для **текущего user‑сообщения** и переключить selected (нормализация/переписывание input)
- создать/обновить **assistant variant** текущего хода (например нормализация/пост‑обработка) *(только `after_main_llm`)*
- обновить `blocks/meta` выбранного assistant‑варианта *(только `after_main_llm`)*

#### C) Artifacts / Memory effects

Операция может:

- создать/обновить `art.<tag>` как **persisted** (между ходами)
- создать `art.<tag>` как **run_only** (только на время этого run)

Строгое правило v2:

- одна операция может записывать (создавать/обновлять) **только один** `art.<tag>` в рамках одного `Run`. Если нужно обновить несколько `tag` — это должно быть несколько операций.

Артефакт должен указывать:

- `tag: string` (адрес `art.<tag>`)
- `usage: "prompt_only" | "ui_only" | "prompt+ui" | "internal"`
- `semantics: "state" | "log/feed" | "lore/memory" | "intermediate" | string`
- `value: unknown` (или `contentType + content`, если это удобнее)
- `retention?: ...` (только для persisted; опционально на старте)

### 4.5 Ошибки и статусность

Operation **не должна падать “сырым исключением” наружу**. Результат ошибки должен быть стабильным:

- `status="error"`
- `error: { code: string; message: string; details?: unknown }` (details bounded/safe)

Коды должны быть стабильными (например `policy_error`, `artifact_conflict`, `validation_error`, `provider_error`).

### 4.6 OperationRun (лог выполнения)

Каждое исполнение операции порождает `OperationRun`:

- `operationId`, `hook`, `trigger`
- `startedAt`, `finishedAt`, `durationMs`
- `status: done|skipped|aborted|error`
- `inputsSummary?` (bounded) и `outputsSummary?` (bounded)
- `errorCode?`, `errorMessage?`

Цель — объяснимость (“почему так вышло”), без хранения чувствительных данных.

## 5) Минимальные правила детерминизма

Чтобы поведение было предсказуемым:

- **Execute vs Commit**
  - операции могут **исполняться параллельно** (execute), но эффекты, влияющие на prompt/UI/канон хода, применяются детерминированно (commit).
- **Правило commit**
  - эффекты операции **применяются только если** `status="done"`.
  - если `status="error|aborted|skipped"`, считаем, что операция **не произвела** эффектов (даже если “успела что-то сделать” внутри).
- **Порядок commit (очередь записи)**
  - сначала соблюдаем зависимости: если `B dependsOn A`, то commit эффектов `A` всегда раньше `B`;
  - среди “готовых к commit” — сортировка по `order` (меньше раньше), затем `operationId` (tie-break).
- **Зависимости**
  - `dependsOn` — строгие: операция стартует только после `done` у deps.
  - если dep завершился `error|aborted|skipped`, зависимая операция **не может стартовать** и должна завершиться терминально:
    - `skipped`, если она `required=false`
    - `error` (например `dependency_failed`), если она `required=true`
- операции взаимодействуют через **явные артефакты и эффекты**, а не “скрытые глобальные переменные”

## 6) Примеры (для понимания модели)

### Пример A: Augmentation до main LLM

Операция `builtin:augmentation_notes` в `before_main_llm`:

- делает aux LLM вызов
- создаёт `art.augmentation_notes` как `run_only` с `usage="prompt_only"` и `semantics="intermediate"`
- возвращает prompt-time effect: вставить синтетическое сообщение после последнего user с `role="developer"` и `content` из артефакта

### Пример B: Обновление состояния мира после main LLM

Операция `builtin:world_state_update` в `after_main_llm`:

- читает ответ ассистента (final text/blocks)
- вычисляет новый `art.world_state` как persisted `usage="prompt+ui"`, `semantics="state"`
- если нужна отладка/дифф — это отдельная операция (например `builtin:world_state_diff`), потому что одна операция пишет только в один `art.<tag>`

---

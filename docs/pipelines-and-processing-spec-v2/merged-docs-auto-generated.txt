

========================================
FILE: 00-terminology.md
========================================

# v2 — Термины и определения (простым языком)

Этот документ задаёт **единый словарь** для спеки v2.
Если термин не определён здесь — считаем, что он ещё не согласован.

## 1) Главная идея v2 (в одном абзаце)

**Operation** в v2 — это **одна исполняемая операция** (одно действие).  
Она может что-то посчитать, сделать aux LLM‑вызов, прочитать/записать артефакты, подготовить изменения текущего хода и вернуть результат.  
Когда именно операция запускается, задаётся **точкой запуска (Hook)** — в v2 их **ровно две**: “до main LLM” и “после main LLM”.  
А то, *почему вообще стартовал run*, задаётся **Trigger** — в v2 их **ровно два**: `generate` и `regenerate`.

> Примечание: термин “Pipeline” (пайплайн) в v2 считаем **legacy** и стараемся не использовать, чтобы не путать “одно действие” с “конвейером из шагов”.

## 2) Сущности (что это такое)

### Operation (операция)

**Operation** — это **одно действие**: “сделай X”.

Примеры операций:

- LLM‑операция: делает свой запрос в LLM по своему промпту → выдаёт результат → применяет эффект (создать/выбрать variant, создать артефакт для prompt или UI и т.п.)
- RAG‑операция: ходит в RAG → возвращает данные (обычно как артефакт)
- Tool‑операция: выполняет функцию/интеграцию → возвращает результат (обычно как артефакт)

Важное: в v2 **операция не состоит из шагов**. Операция и есть “единица исполнения”.

Операция **ничего не говорит** про “до/после main LLM” сама по себе — это задаётся тем, **в каком hook** она стоит.

### Hook (точка запуска)

**Hook** — это “где внутри run запускаем операцию” (позиция относительно main LLM).
В v2 список hook‑ов **фиксирован** и расширяться не будет:

- `before_main_llm` — до основной генерации
- `after_main_llm` — после завершения основной генерации

### Trigger (триггер запуска)

**Trigger** — это “почему стартовал run” (какое действие пользователя/системы породило запуск).
В v2 список trigger‑ов **фиксирован** и расширяться не будет:

- `generate` — обычная генерация (новый ответ на текущий ход)
- `regenerate` — перегенерация (повторная генерация вместо/как новый variant)

### OperationProfile (профиль операций)

**OperationProfile** — набор включённых операций и их конфигураций.
Это **конфиг**, а не выполнение.

Важно: профиль отвечает на вопрос “какие операции запускать в каком hook”.
При необходимости профиль также может различать конфигурацию по trigger (например, запускать часть операций только на `generate` или только на `regenerate`).
Также профиль может быть **полностью выключен** (`enabled=false`), чтобы `Run` выполнялся как “чистая генерация main LLM” без операций.

### OperationProfileSession (сессия профиля операций)

**OperationProfileSession** — это **персистентное состояние между `Run`**, с которым работают операции.
Проще: “долгоживущий контейнер данных”, где лежат persisted‑артефакты и их `history[]`, чтобы:

- операции могли читать/обновлять накопленное состояние,
- данные переживали перезапуски приложения/сервера и были доступны между “игровыми сессиями” (т.к. хранятся в БД).

Важно: `Run` — это разовое выполнение “сейчас”, а `OperationProfileSession` — то, что **живёт между run** и “питается” ими.

#### OperationProfileSessionId (resettable id)

**OperationProfileSessionId** — “сбрасываемый” идентификатор сессии профиля.
Если пользователь **перегенерирует** его, система начинает работать с **новой** `OperationProfileSession` (логический “start fresh”), не смешивая новые результаты со старым накопленным состоянием.

#### OperationProfileSessionKey (ключ выбора сессии)

**OperationProfileSessionKey** — ключ, по которому выбирается/создаётся `OperationProfileSession`.
Минимальная идея: сессия определяется контекстом чата и профиля, например:

- `chatId`
- `branchId`
- `operationProfileRef` (или эквивалентный идентификатор профиля)
- `operationProfileSessionId`

Примечание: мы используем термин **OperationProfileSession** намеренно, чтобы не путать это с “сессией пользователя”, “сессией UI”, “SSE-сессией” и т.п.

### Run (запуск)

**Run** — конкретный запуск системы операций по **trigger** (пока: `generate` / `regenerate`).
Run — это “контейнер” для всех операций, которые отработали в рамках этого запуска.

### OperationRun (выполнение операции)

**OperationRun** — лог *конкретного выполнения* конкретной операции в рамках Run:

- когда стартовал/закончился,
- чем закончился (ok/error/aborted),
- какие были входы/выходы (в разумных лимитах),
- какие были ошибки (стабильный код + безопасное сообщение).

Важно: Operation (в профиле) — “что сделать”, OperationRun — “как это реально отработало в этот раз”.

### Main LLM (основная генерация)

**Main LLM** — это **core‑процесс основной генерации**, встроенный в систему чата и выполняющийся **по своему отдельному жизненному циклу**.
В рамках v2 мы **не управляем им напрямую** как обычной `Operation`: операции не “встраиваются внутрь” main LLM и не могут пошагово редактировать его выполнение.

Роль main LLM в `Run`:

- он является **разделительной границей** для хуков: операции могут выполняться **только `before_main_llm`** и **`after_main_llm`** относительно этого процесса;
- он использует **effective prompt**, подготовленный системой (chat history + синтетические вставки/артефакты/результаты операций), и запускает **основной LLM‑вызов**;
- результат main LLM — это **генерация ответа ассистента** (обычно со стримингом в UI) и **запись результата в историю чата** как новый/обновлённый **assistant variant** текущего хода.

На текущий момент в каждом `Run` выполняется **ровно один** main LLM‑вызов.
`Aux LLM` вызовы внутри операций **не связаны** с ним напрямую и **не влияют** на него “изнутри” — они могут повлиять на итог **только через свои результаты**, которые операции применяют **до** main LLM (например, меняя effective prompt / создавая артефакты для включения в prompt) или **после** main LLM (например, меняя UI/артефакты/варианты текущего хода).

### Aux LLM (вспомогательная генерация)

**Aux LLM** — LLM‑вызов операции, который:

- **не** стримит в chat history как “основной ответ ассистента”,
- используется, чтобы произвести данные/артефакты/варианты для main LLM или UI.

### Artifact (артефакт)

**Artifact** — результат работы операций, который живёт отдельно от истории сообщений.
У артефакта есть **две независимые оси**:

1) **Как используется (видимость / usage)** — *кто это видит и где применяется*:

- **prompt_only** — участвует только в effective prompt
- **ui_only** — показывается только в UI
- **prompt+ui** — и участвует в effective prompt, и показывается в UI
- **internal** — не участвует в effective prompt и не показывается в UI (нужен только для вычислений/связок между операциями)

2) **Что это по смыслу (kind / semantics)** — *что именно хранится*:

- **state** — состояние/память мира (погода/время/локация/статы и т.п.)
- **log/feed** — лента/журнал событий
- **lore/memory** — лор/память персонажей
- **intermediate** — промежуточный результат (в т.ч. guard-флаги, tool-выходы, кэш).  
  Обычно такой артефакт имеет usage=`internal`, но при необходимости может быть и `prompt_only` (если надо скормить main LLM) или `ui_only` (если надо показать отладку/индикатор).

Артефакт адресуется как `art.<tag>` и имеет минимум `value`.  

**Область видимости `tag`**: каждый `tag` должен быть **уникальным в рамках одного OperationProfile** (т.е. набора/“пайплайна” операций). Коллизия `tag` в одном профиле — это ошибка конфигурации.
Также в v2 действует строгое правило: **одна операция может писать (создавать/обновлять) только в один `art.<tag>`**. Если нужно обновить несколько артефактов — это несколько операций.
Детали “persisted vs run_only” и “может ли быть history” — см. раздел **3.3** ниже.

#### Пример, чтобы не путаться

`art.world_state` может быть:

- **state** по смыслу (semantics)
- и **prompt+ui** по использованию (usage), чтобы и LLM, и пользователь видели текущее состояние.

### ChatHistory (история чата)

**ChatHistory** — канонический поток сообщений чата.  
В v2 сохраняем принцип: операции **не переписывают прошлую историю “задним числом”**.

Важно: `ChatHistory` — это история сообщений чата, а `history[]` у артефакта — это история прошлых состояний конкретного `art.<tag>` (см. **3.3**).

При этом операции могут влиять на:

- **текущий ход (turn)** (например, выбрать/создать variant для текущего сообщения),
- **effective prompt** (что уйдёт в main LLM),
- **артефакты** (память/панели/ленты/данные).

### Turn (ход)

**Turn (ход)** — это текущий “вопрос пользователя” (конкретный `userMessageId`) и все связанные с ним варианты ответа ассистента (**assistant variants**).

Правила:

- `trigger=generate` начинает **новый turn** (создаётся новый `userMessageId`).
- `trigger=regenerate` запускает новый `Run` **в рамках того же turn** и создаёт/добавляет новый **assistant variant** для текущего `userMessageId`.

### Variant (вариант сообщения)

**Variant** — альтернативная форма одного и того же сообщения (user или assistant), из которых выбирается “активная/выбранная” версия.
Это механизм “изменить текущий ход” без переписывания истории задним числом.

### Effective prompt (фактический промпт)

**Effective prompt** — то, что реально уходит в main LLM в этот раз:

- system prompt,
- часть chat history,
- синтетические вставки (например, из артефактов или результатов операций).

### PromptInclusion (включение артефакта в effective prompt)

**PromptInclusion** — это правило, которое описывает **как именно** артефакт (чаще всего persisted) попадает в effective prompt.

Минимальная идея:

- можно включать артефакт как “кусок system”,
- как отдельное синтетическое сообщение,
- или вставлять “после последнего user”,
- при необходимости — с более точным якорем/глубиной (см. примеры в **3.1 Prompt-time**).

## 3) Три слоя изменений (очень важная рамка)

Слои нужны, чтобы **не смешивать разные “виды правды”** и не получать “магии”.
Любой эффект операции должен быть отнесён к одному (или нескольким) из слоёв ниже.

### 3.1 Prompt-time (одноразово для effective prompt)

**Что это**: операция влияет **только на effective prompt текущего main LLM вызова**.  
История чата в БД при этом **не меняется**.

**Важно**: effective prompt — это не только system-инструкция, а **весь набор сообщений**, который реально уходит в main LLM:

- system prompt,
- выбранная chat history (promptText выбранных вариантов),
- синтетические сообщения/вставки (созданные операциями).

**Что можно делать** (примеры):

- сделать aux LLM вызов и вставить “working notes / план / augmentation” как `prompt_only` сообщение;
- сделать RAG и вложить найденный контекст в effective prompt (в system или “после последнего user”);
- вставить одноразовое сообщение **на глубину** (не только в конец), задав:
  - якорь (после последнего user / после messageId / offset от конца),
  - место (before/after/replace),
  - и политику, что делать, если якорь не попал в окно из‑за trimming.

### 3.2 Turn canonicalization (канонизация текущего хода)

**Что это**: операция меняет **канон текущего хода**, но **не переписывает прошлое**.

Идея простая: если ты хочешь, чтобы результат “жил дальше” в истории чата и использовался на следующих ходах,
его нужно закрепить как **selected variant** (или как blocks/meta) **текущего** сообщения.

**Что можно делать** (примеры):

- для текущего `userMessageId`: создать variant “перевод/переписанный голосом персонажа” и сделать его selected  
  → на следующем ходу chat history будет использовать именно этот текст (пока selection не переключат обратно);
- для текущего `assistantVariantId`: нормализовать ответ, записать blocks.

### 3.3 Artifacts / Memory (данные и состояние рядом с историей)

**Что это**: операция читает/пишет **артефакты** — отдельный слой данных, который живёт рядом с историей сообщений.

**Базовые правила (v2)**:

1) **Любой артефакт адресуется как `art.<tag>`** и имеет минимум `value`.
2) **persisted** артефакт **живёт между run** и доступен в следующих ходах; он **может иметь историю** (`history[]`) по retention.
3) **run_only** артефакт — **эфемерный результат исполнения**, который существует только *во время* одного run и **не сохраняется** между ходами; он **не может иметь историю**.

**Примеры persisted**:

- **State-панель (долговременная память мира)**: `art.world_state` (json) хранит время/погоду/локацию и обновляется после каждого хода. UI показывает `value`, а история версий (`history[]`) может использоваться для диффа/отладки.
- **Лор/память персонажей**: `art.lore` (markdown/text) живёт между ходами и включается в effective prompt через `promptInclusion` (например `prepend_system`).
- **Лента событий**: `art.combat_log` (markdown/text) хранит последние \(N\) записей как timeline (через retention) и отображается в UI как feed.

**Зачем нужен run_only**: чтобы передавать/кэшировать результаты **между операциями внутри одного запуска**, не превращая это в “память чата”.
Это снижает когнитивную нагрузку (не нужно думать “чистить ли это между ходами”), избегает “утечек” данных в следующий ход и позволяет держать большие/временные результаты без сохранения в БД.

**Примеры run_only**:

- **Guard-флаг для ветвления внутри run**: операция анализирует последние \(N\) сообщений и возвращает `isCombat=true/false` для этого запуска, чтобы далее включить/пропустить операции “дайсы/бой”. На следующий ход этот флаг не обязан жить.
- **Большой одноразовый контекст для main LLM**: RAG/aux LLM собирает 10k токенов справки/augmentation для *одного* ответа и отдаёт это как run_only результат (при желании логируется summary/hash), не сохраняя между ходами.
- **Промежуточный tool-результат/кэш**: операция сходила в API и вернула сырой JSON, который нужен только следующим операциям в этом же run (например для расчёта), но не нужен как долговременный артефакт.

**Важно**: артефакты — это про **хранение данных**, а то, **как это показывать в UI** (панель/лента/внутри чата) — это **отдельная проекция** и не равно retention.

---

Исторические трансформации (переписывание прошлого) — **отдельный класс операций** и по умолчанию не часть v2 core.



========================================
FILE: 10-operation.md
========================================

# v2 — Operation (контракт и модель исполнения)

Этот документ фиксирует, **что такое Operation**, как она исполняется в рамках `Run`, и какой у неё **контракт** (входы/выходы/эффекты/ошибки/логирование).

> Принцип v2: **Operation — это blackbox-единица исполнения**.  
> Она может делать сколько угодно внутренней работы (aux LLM, вычисления, интеграции), но наружу отдаёт только **явные эффекты**.

## 1) Что такое Operation (в одном абзаце)

**Operation** — это **одно исполняемое действие** (“сделай X”), которое запускается в одном из **двух хуков**:

- `before_main_llm` — до main LLM
- `after_main_llm` — после main LLM

Operation получает **контекст текущего запуска (`Run`)** и возвращает **набор эффектов** в один или несколько слоёв:

- **Prompt-time**: влияет на effective prompt *только для этого* main LLM вызова
- **Turn canonicalization**: меняет канон *текущего хода* (variants/selected, blocks/meta и т.п.), не переписывая прошлое
- **Artifacts / Memory**: читает/пишет `art.<tag>` (persisted или run_only)

Operation **не “встраивается внутрь” main LLM** и не управляет его стримингом/flush’ем. Main LLM остаётся отдельным процессом, а Operation влияет на него только через подготовленные данные и канонизацию результата.

## 2) Зачем v2 убирает `pre/post` и “шаги”

В v2 мы сознательно **не описываем** систему как “пайплайны = список шагов (`pre/llm/post`)”, потому что:

- в реальности “пайплайны” были **blackbox**, а не набором настраиваемых шагов;
- `pre/post` — это **внутренняя раскладка оркестратора**, а не понятная пользователю единица настройки;
- нам нужно без переименований добавлять новые типы действий (RAG, tool, нормализации, state updates) **как до**, так и **после** main LLM.

Вместо этого v2 делает единицей конфигурации **Operation**, а точка запуска задаётся явно через **Hook**.

## 3) Место Operation в Run

`Run` запускается по `Trigger`:

- `generate` — новый ход
- `regenerate` — новый вариант ассистента в рамках текущего хода

Далее (минимальная модель v2):

1. Запустить операции `before_main_llm`:
   - операции **могут исполняться параллельно**,
   - но операция **не стартует**, пока все её зависимости не завершились со статусом **`done`** (см. `dependsOn`).
2. Дождаться, пока **все** операции `before_main_llm`, которые должны были запуститься в этом `Run`, завершатся в **терминальном статусе** (`done|error|aborted|skipped`).
3. Если среди `before_main_llm` есть операции с `required=true`, завершившиеся **не** `done` → `Run` считается неуспешным, и **main LLM не стартует**.
4. Исполнить **ровно один** `main LLM` вызов (используя effective prompt), только если барьер пройден.
5. Исполнить операции `after_main_llm` (так же: параллельно + ожидание зависимостей).
6. Зафиксировать итоговые статусы `Run`/`OperationRun` и применённые эффекты

## 4) Контракт Operation (минимальный)

### 4.1 OperationDefinition (что это за операция)

**OperationDefinition** — описание “что это за операция” (идентичность и диспетчеризация):

- `operationId: string` — стабильный идентификатор (например `builtin:world_state_update`)
- `name: string` — человекочитаемое имя
- `description?: string` — кратко “зачем”
- `kind: "llm" | "rag" | "tool" | "compute" | "transform" | "legacy" | string`
- `capabilities?: { ... }` — опционально: декларация того, что операция *может* делать (см. 4.4)

> Важно: v2 не требует, чтобы операция “состояла из шагов”. Её внутренняя реализация — произвольна.

### 4.2 OperationConfig (как она настроена)

**OperationConfig** — набор параметров, который определяет, *как именно* эта операция должна выполняться:

- `enabled: boolean`
- `required: boolean` — обязательна ли операция для успешного продолжения `Run`.
  - если `required=true`, то операция должна завершиться **`done`**, иначе `Run` не продолжается через барьер (для `before_main_llm`) или помечается как неуспешный (для `after_main_llm`).
  - если `required=false`, то `error/aborted/skipped` **не блокируют** продолжение `Run`.
  - важное уточнение для `after_main_llm`: `required=true` **не откатывает** уже выполненный main LLM и не “отменяет” записанный assistant variant. Это только сигнал, что Run считается **failed** (и, соответственно, UI/логика ретрая/наблюдаемость должны показывать, что пост-операции не завершились успешно).
- `hooks: ("before_main_llm" | "after_main_llm")[]` (обычно один)
- `triggers?: ("generate" | "regenerate")[]` (если не задано — оба)
- `order: number` — **обязательный** приоритет/порядок внутри hook (меньше = раньше).
  - `order` влияет не только на “порядок в списке”, но и на **очередь применения эффектов** (commit) для prompt/UI/канона хода, даже если операции исполняются параллельно.
- `dependsOn?: string[]` — список `operationId`, от которых зависит эта операция.
  - строгое правило: операция **не стартует**, пока все `dependsOn` не завершились со статусом **`done`**.
  - если операции нужно **гарантированно** прочитать результат другой операции (особенно `run_only` артефакт) — она обязана явно указать зависимость через `dependsOn`.
- `params: Record<string, unknown>` — конфигурация операции.
- `debug?: { enabled?: boolean }`

#### 4.2.1 Где живут “параметры, зависящие от kind”

В v2 все пользовательские параметры, которые влияют на **внутреннюю работу** конкретной операции, живут в `OperationConfig.params`.

Ключевое правило:

- `OperationDefinition.kind` определяет **схему** `params` (дискриминируемый контракт).
- `params` хранится как JSON, но семантически является **типизированным объектом**, зависящим от `kind`.
- Секреты (API keys) **никогда** не лежат в `params`: там только ссылки/идентификаторы провайдеров и настройки, безопасные для хранения.

`kind="llm"` (aux LLM-операции) описываем отдельно: см. [`11-operation-kind-llm.md`](./11-operation-kind-llm.md).

### 4.3 OperationContext (что операция “видит”)

**OperationContext** — вход операции (read-only источник правды):

- **Run meta**
  - `runId`, `trigger`, `hook`
  - `chatId`, `branchId`, `turnId`/`userMessageId`, `assistantVariantId?`
- **Main LLM граница**
  - если `hook=before_main_llm`: доступен “черновик” effective prompt (см. ниже)
  - если `hook=after_main_llm`: доступен результат main LLM (selected assistant variant + финальный текст/blocks/meta)
- **Artifacts**
  - read-доступ к `art.<tag>` (persisted) и к run-local данным, **но** операция не должна полагаться на наличие run-local результата другой операции без явной зависимости через `dependsOn`
- **Abort/Deadlines**
  - `abortSignal`/`deadlineMs?`
- **Policy (минимум)**
  - ограничения на эффекты: что можно писать/менять в этом хуке
  - лимиты на размер логов/снапшотов

> В v2 контекст обязан быть таким, чтобы операция могла быть “честным blackbox”: всё, что ей нужно знать о мире, приходит через контекст.

### 4.4 OperationResult (что операция возвращает)

Operation возвращает **результат исполнения** и **набор эффектов**.

Минимальная форма:

- `status: "done" | "skipped" | "error" | "aborted"`
- `required: boolean` — *эхо из `OperationConfig.required`* (чтобы по результату/логам было видно, была ли операция обязательной и почему `Run` мог продолжиться после её ошибки).
- `effects: OperationEffects`
- `debug?: OperationDebug` (bounded, безопасный)

Где `OperationEffects` делятся по слоям:

> Примечание: точная схема `OperationEffects` и детальный механизм применения эффектов (позиционирование, trimming, якоря и т.п.) будут описаны **в отдельном документе**. Здесь фиксируем минимальный набор, достаточный для согласования модели.

#### Про `status="skipped"` (важно)

`skipped` — **валидный терминальный статус**. Он означает, что операция была **осознанно пропущена** (не выполнялась или досрочно завершилась без выполнения) по правилам конфигурации/политики/условия и это **не является ошибкой**.

Правила:

- `skipped` **не коммитит эффекты**: если операция `skipped`, считаем, что она **не произвела** `effects`.
- `skipped` может возникать, например, когда:
  - операция отключена (`enabled=false`);
  - операция не применяется к текущему `trigger` (если задан `triggers[]`);
  - операция сама решила “ничего не делать” по условию (guard/condition);
  - операция не может стартовать из‑за зависимостей (см. правила зависимостей).

Рекомендуется (не обязательно на старте) фиксировать причину пропуска как `skippedReason` (например: `disabled | trigger_mismatch | condition_false | dependency_failed | policy`), чтобы дебаг был объяснимым.

##### Пример: guard → условное выполнение зависимых операций

Операция‑guard `builtin:is_combat_guard` в `before_main_llm`:

- выполняется и завершаетcя `done`,
- пишет `art.is_combat` как `run_only` boolean (`true/false`).

Зависимые операции (например `builtin:combat_rag`, `builtin:combat_dice`) задают `dependsOn=["builtin:is_combat_guard"]`, читают `art.is_combat` и:

- если `true` → выполняются и завершаются `done`,
- если `false` → возвращают `skipped` (например с `skippedReason="condition_false"`).

#### A) Prompt-time effects

Эти эффекты **меняют effective prompt только для текущего main LLM вызова** и не становятся частью истории.

Ограничение:

- prompt-time эффекты применяются **только** в `before_main_llm` (после старта main LLM менять prompt уже нельзя).

Минимальный набор эффектов (не финальный, но достаточный для старта):

##### 1) `prompt.append_after_last_user` — вставка после текущего user input

Добавляет **синтетическое prompt-only сообщение** сразу после **текущего user‑сообщения**, которое породило `Run`.

Ключевой инвариант v2: main LLM не стартует, пока `before_main_llm` завершён, поэтому “текущий user” считается всегда доступным как якорь для вставки.

##### 2) `prompt.system_update` — модификация system prompt

Меняет **system prompt** в effective prompt одним из режимов:

- `mode="prepend"` — `payload + system` (добавить *перед* текущим system)
- `mode="append"` — `system + payload` (добавить *после* текущего system)
- `mode="replace"` — `system := payload` (полностью заменить system по правилам операции)

##### 3) `prompt.insert_at_depth` — вставка “в хвост” и “на глубину”

Унифицированный эффект для:

- **вставки в хвост** (глубина = 0),
- **вставки “на глубину”** (например “вставить за N сообщений до конца”).

Форма:

- `depthFromEnd: number`
  - `0` = вставить в самый конец effective prompt (tail)
  - `-N` = вставить “на глубину” (внутрь контекста, ближе к концу)

Точный механизм позиционирования/якорей/что делать при trimming/границах будет описан отдельно, но **порядок применения** всегда детерминированный (см. commit-очередь).

Payload для сообщения:

- `role: "system" | "developer" | "user" | "assistant"`
- `content: string`
- `source?: string` (например `art.world_state`)

#### B) Turn canonicalization effects

Эти эффекты меняют **канон текущего хода**, но не переписывают прошлую историю.
Канон хода включает:

- **текущее user‑сообщение** (текущий input, который породил `Run`)
- **assistant‑ответ текущего хода** (variants/selected/blocks/meta), если он уже существует

Ограничения по хукам:

- в `before_main_llm` операция может канонизировать **только user‑часть** (потому что assistant‑ответа ещё нет)
- в `after_main_llm` операция может канонизировать **и user‑часть, и assistant‑часть**

Типовые эффекты (примеры):

- создать/обновить variant для **текущего user‑сообщения** и переключить selected (нормализация/переписывание input)
- создать/обновить **assistant variant** текущего хода (например нормализация/пост‑обработка) *(только `after_main_llm`)*
- обновить `blocks/meta` выбранного assistant‑варианта *(только `after_main_llm`)*

#### C) Artifacts / Memory effects

Операция может:

- создать/обновить `art.<tag>` как **persisted** (между ходами)
- создать `art.<tag>` как **run_only** (только на время этого run)

Строгое правило v2:

- одна операция может записывать (создавать/обновлять) **только один** `art.<tag>` в рамках одного `Run`. Если нужно обновить несколько `tag` — это должно быть несколько операций.

Артефакт должен указывать:

- `tag: string` (адрес `art.<tag>`)
- `usage: "prompt_only" | "ui_only" | "prompt+ui" | "internal"`
- `semantics: "state" | "log/feed" | "lore/memory" | "intermediate" | string`
- `value: unknown` (или `contentType + content`, если это удобнее)
- `retention?: ...` (только для persisted; опционально на старте)

### 4.5 Ошибки и статусность

Operation **не должна падать “сырым исключением” наружу**. Результат ошибки должен быть стабильным:

- `status="error"`
- `error: { code: string; message: string; details?: unknown }` (details bounded/safe)

Коды должны быть стабильными (например `policy_error`, `artifact_conflict`, `validation_error`, `provider_error`).

### 4.6 OperationRun (лог выполнения)

Каждое исполнение операции порождает `OperationRun`:

- `operationId`, `hook`, `trigger`
- `startedAt`, `finishedAt`, `durationMs`
- `status: done|skipped|aborted|error`
- `inputsSummary?` (bounded) и `outputsSummary?` (bounded)
- `errorCode?`, `errorMessage?`

Цель — объяснимость (“почему так вышло”), без хранения чувствительных данных.

## 5) Минимальные правила детерминизма

Чтобы поведение было предсказуемым:

- **Execute vs Commit**
  - операции могут **исполняться параллельно** (execute), но эффекты, влияющие на prompt/UI/канон хода, применяются детерминированно (commit).
- **Правило commit**
  - эффекты операции **применяются только если** `status="done"`.
  - если `status="error|aborted|skipped"`, считаем, что операция **не произвела** эффектов (даже если “успела что-то сделать” внутри).
- **Порядок commit (очередь записи)**
  - сначала соблюдаем зависимости: если `B dependsOn A`, то commit эффектов `A` всегда раньше `B`;
  - среди “готовых к commit” — сортировка по `order` (меньше раньше), затем `operationId` (tie-break).
- **Зависимости**
  - `dependsOn` — строгие: операция стартует только после `done` у deps.
  - если dep завершился `error|aborted|skipped`, зависимая операция **не может стартовать** и должна завершиться терминально:
    - `skipped`, если она `required=false`
    - `error` (например `dependency_failed`), если она `required=true`
- операции взаимодействуют через **явные артефакты и эффекты**, а не “скрытые глобальные переменные”

## 6) Примеры (для понимания модели)

### Пример A: Augmentation до main LLM

Операция `builtin:augmentation_notes` в `before_main_llm`:

- делает aux LLM вызов
- создаёт `art.augmentation_notes` как `run_only` с `usage="prompt_only"` и `semantics="intermediate"`
- возвращает prompt-time effect: вставить синтетическое сообщение после последнего user с `role="developer"` и `content` из артефакта

### Пример B: Обновление состояния мира после main LLM

Операция `builtin:world_state_update` в `after_main_llm`:

- читает ответ ассистента (final text/blocks)
- вычисляет новый `art.world_state` как persisted `usage="prompt+ui"`, `semantics="state"`
- если нужна отладка/дифф — это отдельная операция (например `builtin:world_state_diff`), потому что одна операция пишет только в один `art.<tag>`

---


========================================
FILE: 11-operation-kind-llm.md
========================================

# v2 — Operation / kind=llm (контракт LLM-операции)

Этот документ описывает **контракт и поведение операций** с `OperationDefinition.kind="llm"`.

> Важно: здесь речь про **aux LLM-операции** (внутри `Operation`).  
> `Main LLM` остаётся отдельным процессом `Run` и **не** описывается как обычная операция.

## 0) Цель и границы (scope)

**Цель**: зафиксировать минимальный, реализуемый контракт для aux LLM-операций, чтобы:

- можно было конфигурировать LLM-операции как обычные `Operation` в профиле,
- поведение было предсказуемым (timeouts/retry/output format),
- логирование было полезным и безопасным.

**Не в scope** этого документа:

- контракт `Main LLM` (это отдельный процесс `Run`);
- подробная схема `OperationEffects` и детальный “движок” применения эффектов (описывается отдельно; здесь только то, что LLM-операция может вернуть как эффекты).

## 1) Что такое LLM-операция в v2 (простыми словами)

**LLM-операция** — это операция, которая делает **ровно один aux LLM-вызов**, получает результат и возвращает его в виде:

- записи в **один** `art.<tag>` (persisted или run_only) — основной способ “выдать данные наружу”,
- и/или дополнительных эффектов (prompt-time / canonicalization), если операция на это рассчитана.

Инварианты:

- LLM-операция — **blackbox**: все внешние эффекты должны быть описаны явно через `OperationResult`.
- LLM-операция **не стримит** “основной ответ ассистента” в chat history (это делает `Main LLM`).
- LLM-операция в v2 **не “ведёт чат”**: она одноразово формирует запрос и выполняется ровно один раз в рамках своего `OperationRun`.

## 2) `params` для `kind="llm"` (базовая структура)

В v2 `OperationConfig.params` для `kind="llm"` — JSON-объект со следующими логическими группами.
Точная типизация будет вынесена в shared types позже, здесь фиксируем форму/смысл.

### 2.1 Provider / Model

- `providerRef: string` — ссылка на провайдера/интеграцию (без секретов; ключи живут вне params)
- `model: string` — имя модели (как понимает провайдер)
- `credentialRef: string` — ссылка на токен/учётку в DB, которая будет использована во время `Run` (**никогда не логируется** и не сохраняется “как есть” в `OperationRun`; допустимо логировать только факт выбора провайдера/credentialRef как opaque id при включённом debug, если нужно).

Примечание (не обязательно для v2 core): в будущем можно добавить `modelRef` (идентификатор модели из каталога приложения) вместо/вместе с `model`, но это не требуется для рабочего минимума.

### 2.2 Prompt (что отправляем в aux LLM)

В v2 (рабочий минимум) LLM-операция — **one-shot**: она отправляет один запрос, который концептуально состоит из:

- `system?: string` — опциональная системная инструкция для aux вызова
- `prompt: string` — “user message” для aux вызова (ровно одна строка)

Оба поля (`system` и `prompt`) являются **LiquidJS-шаблонами** и рендерятся в строку перед выполнением aux LLM-вызова.
В шаблоне доступны, как минимум:

- `art.<tag>` — все артефакты (`art.stats`, `art.world_state`, и т.п.)
- `chatHistory` — история чата (с фильтрами/хелперами Liquid, например `{{ chatHistory | last: 5 }}` — точная форма фильтров фиксируется отдельно)

Примечание про “наличие данных”:

- наличие/отсутствие конкретных `art.<tag>` — часть ответственности пользователя при настройке профиля/связей операций;
- система должна быть прозрачной: указывать, **что** доступно в контексте и **как** это настроить;
- если пользователю нужна гарантия, что run-local артефакт появится “к моменту рендера”, он настраивает связи через `dependsOn` (см. v2 модель зависимостей).

Опционально:

- `strictVariables?: boolean` — режим строгих переменных при рендере LiquidJS.
  - если `true`: обращение к отсутствующему полю/переменной при рендере считается ошибкой и операция завершается `status="error"` (например `error.code="template_render_error"`).
  - если `false`/не задано: поведение определяется настройками Liquid по умолчанию (обычно “рендерим пусто”).
- `maxInputTokens?: number` — мягкий лимит на вход (если поддерживается)

> Примечание: в будущем это можно расширить до `messages[]` или `promptTemplateRef + vars`, но в v2 core фиксируем one-shot модель, чтобы не создавать “второй чат внутри операции”.

### 2.3 Sampling / Limits

- `samplers?: { temperature?: number; topP?: number; topK?: number; frequencyPenalty?: number; presencePenalty?: number; seed?: number }`
- `maxOutputTokens?: number`
- `stop?: string[]`
- `budget?: { maxCostUsd?: number }`

### 2.4 Output / Parsing

- `output?: { mode: "text" | "json"; schemaRef?: string }`
  - `mode="text"` — ожидаем обычный текст
  - `mode="json"` — ожидаем JSON; `schemaRef` опционально (валидация по схеме)

`mode="json"` — **опциональный best-effort режим**, который зависит от провайдера/модели и корректности промпта. Это ответственность пользователя, а не системы: система не гарантирует, что модель вернёт валидный JSON.

Политика v2:

- если `mode="json"` и результат **не парсится** как JSON → операция завершаетcя `status="error"` (например `error.code="output_parse_error"`).
- если операция `required=true` и находится в `before_main_llm`, то этот `error` **останавливает Run** до main LLM (см. барьер в модели Operation).

В UI можно будет “проверить схему/валидность” (`schemaRef`), но механика валидации описывается отдельным документом.

### 2.5 Куда записать результат (обязательная часть v2)

Так как действует правило v2 “одна операция пишет только в один `art.<tag>`”, LLM-операция должна явно знать, куда писать результат.

- `writeArtifact: { tag: string; persisted: boolean; usage: "prompt_only" | "ui_only" | "prompt+ui" | "internal"; semantics: "state" | "log/feed" | "lore/memory" | "intermediate" | string }`

Примечание: `retention` для persisted артефактов описывается в спеках артефактов/памяти, а не в контракте `kind="llm"`.

### 2.6 Поведение выполнения

- `timeoutMs?: number`
- `retry?: { maxAttempts: number; backoffMs?: number; retryOn?: ("timeout" | "provider_error" | "rate_limit")[] }`

## 3) Входы (`OperationContext`) и ограничения

LLM-операция читает из `OperationContext`:

- базовую meta (`runId`, `hook`, `trigger`, `chatId`, `turnId/userMessageId`, и т.п.)
- `art.<tag>` (persisted и/или run-local)  
  (если нужно гарантировать наличие run-local результата — обеспечиваем через `dependsOn`)
- `abortSignal` / `deadlineMs?`

Ограничения:

- LLM-операция не должна утекать секретами в логи/артефакты.
- В `before_main_llm` LLM-операция может влиять на effective prompt только через **prompt-time эффекты** (и только пока не прошёл барьер).

Примечание: синтаксис LiquidJS, фильтры и полный список доступных переменных (включая `chatHistory`) **не являются зоной ответственности этого документа** и описываются отдельно.

## 4) Выходы (`OperationResult`) и эффекты

### 4.1 Минимальный результат

LLM-операция возвращает:

- `status: "done" | "skipped" | "error" | "aborted"`
- `effects` (обычно включает запись `art.<tag>` по `params.writeArtifact`)

### 4.2 Что считается “результатом” LLM-операции

Минимально: значение, которое будет записано в артефакт:

- при `output.mode="text"`: `value` = строка
- при `output.mode="json"`: `value` = объект (если распарсилось), иначе `status="error"` по политике `output_parse_error` (см. раздел 2.4)

Опционально (bounded, для дебага):

- `debug.providerRequestSummary` (без секретов)
- `debug.providerResponseSummary` (без больших/чувствительных payload)

Для `mode="json"` сохраняем `rawText` (bounded) как часть debug/summary, чтобы было видно, почему JSON не распарсился.
При этом “сырой ответ” не должен логироваться без ограничений: сохраняем только безопасный/усечённый вариант и/или хэш.

## 6.1 Рекомендация: поля для `OperationRun.inputsSummary/outputsSummary` (LLM)

Ниже — рекомендуемый набор полей для объяснимого дебага. Все поля должны быть **bounded** (обрезка, лимиты) и без секретов.

`inputsSummary` (минимум):

- `providerRef`, `model`
- `outputMode` (`text|json`), `schemaRef?`
- `samplers` (только численные параметры), `maxOutputTokens?`, `stop?`
- `timeoutMs?`, `retry?` (только конфиг)
- `strictVariables?`
- `renderedSystemHash?`, `renderedPromptHash?` (хэш итоговых строк после Liquid render, чтобы понимать “что было отправлено” без логирования текста)

`outputsSummary` (минимум):

- `attempts` (сколько попыток реально сделали с учётом retry)
- `durationMs`
- `providerRequestId?` / `providerTraceId?` (если провайдер возвращает)
- `usage?` (если провайдер возвращает): `inputTokens?`, `outputTokens?`, `totalTokens?`, `costUsd?`
- `finishReason?`
- при `mode="json"`:
  - `rawTextPreview?` (усечённый текст ответа, например первые N символов)
  - `rawTextHash?`
  - `parseErrorMessage?` (кратко, bounded), если парсинг упал

## 5) Ошибки, ретраи, таймауты

Базовая идея:

- таймаут по `timeoutMs` / `deadlineMs` → `status="error"` (или `aborted`, если это отмена пользователем)
- при `retry.maxAttempts>1` делаем повтор по `retryOn`

Рекомендованные коды ошибок (черновик):

- `timeout`
- `rate_limited`
- `provider_error`
- `output_parse_error`
- `budget_exceeded`
- `policy_error`

## 6) Логирование и безопасность

Минимальные требования:

- не логировать “сырой prompt” и “сырой ответ” без явного `debug.enabled` и лимитов
- всегда редактировать/обрезать большие поля (bounded summaries)
- не хранить secrets в `params` и в `debug`

Рекомендуемые лимиты для bounded summaries (можно менять реализацией, но это хороший дефолт):

- **`rawTextPreview`**: первые **1024** символа
- **`parseErrorMessage`**: первые **512** символов
- **`stop[]`**: максимум **10** элементов, каждый максимум **120** символов (в summary)
- **`samplers`**: только численные значения; без “производных” полей
- **`renderedSystemHash` / `renderedPromptHash`**: всегда можно логировать (это хэш, не контент)

Redaction (минимум):

- маскировать строки, похожие на ключи/токены (по простым эвристикам)
- никогда не логировать `credentialRef` в явном виде, если он может быть чувствительным; если нужен дебаг — логировать только opaque id при включённом debug

## 7) Открытые вопросы (чтобы дополнять вместе)

На данный момент — нет критичных открытых вопросов для рабочего минимума `kind="llm"`.



========================================
FILE: 12-operation-kind-template.md
========================================

# v2 — Operation / kind=template (text + optional Liquid)

Этот документ описывает **контракт** для операций с `OperationDefinition.kind="template"`.

Идея: это **максимально простая операция**, у которой в конфиге есть **одно** большое текстовое поле.  
Этот текст **может** содержать LiquidJS-синтаксис (подстановки/фильтры), но **не обязан** — если Liquid не используется, результат будет тем же текстом.

## 0) Что это (простыми словами)

`kind="template"` — это операция “взяли строку из конфигурации → (опционально) отрендерили как Liquid по контексту Run → получили строку”.

Типичные кейсы:

- хранить “кусок промпта”, который включается гардом и вставляется в инструкции (через эффекты prompt-time или через артефакт);
- рендерить текст/HTML-фрагмент для UI на основе `art.*` (например `art.stats`).

## 1) Инварианты

- Операция **не вызывает LLM**.
- В конфигурации операции есть **ровно одно** пользовательское текстовое поле.
- Результат операции — **строка**.
- Операция может воздействовать на внешний мир только через `OperationResult.effects` (см. `10-operation.md`).
- Если операция завершилась не `done`, считаем что эффекты **не применились** (общие правила commit в `10-operation.md`).

## 2) `params` для `kind="template"` (минимум)

`OperationConfig.params` для `kind="template"` — JSON-объект:

- `template: string` — текст/шаблон (одно поле в UI)
- `strictVariables?: boolean` — если `true`, обращение к отсутствующим переменным → `status="error"` (`error.code="template_render_error"`)

Контекст шаблона (минимум):

- `art.<tag>` — артефакты (persisted и/или run_only)
- `chatHistory` — история чата (форма/фильтры описываются отдельной спекой LiquidJS-окружения)

## 3) Выполнение (execute)

1) Сформировать render context из `OperationContext` (см. `10-operation.md`).
2) Пропустить `params.template` через LiquidJS renderer и получить `rendered: string`.
   - если в тексте нет Liquid-конструкций, `rendered` будет равен исходному тексту (по смыслу).
3) Вернуть `OperationResult.status="done"` и эффекты, определённые конкретной операцией:
   - prompt-time эффекты (например вставка/обновление инструкций), и/или
   - запись **в один** `art.<tag>` (если операция пишет артефакт — действует правило v2 “1 операция → 1 tag”).

> Примечание: конкретно *куда* попадает `rendered` (в prompt-time, в UI, в артефакт) — это часть поведения конкретной операции (`operationId`) и её эффектов; `kind="template"` фиксирует только то, что источником является один текст/шаблон и результат — строка.

## 4) Ошибки (минимум)

- ошибка рендера Liquid (синтаксис/strictVariables) → `status="error"`, `error.code="template_render_error"`



========================================
FILE: 20-operation-profile.md
========================================

# v2 — OperationProfile (хранилище операций)

Этот документ фиксирует **что такое `OperationProfile` как DB‑сущность**: какие поля он хранит и **какие базовые проверки можно/нужно делать при сохранении**.

Ключевой принцип: `OperationProfile` — **максимально “глупое” хранилище** (контейнер), он **ничего не исполняет**, **не планирует** и **не “строит Run”**. Исполнение и планирование относятся к процессу `Run`/оркестратору и описываются отдельно.

Связанные документы:

- Термины: [`00-terminology.md`](./00-terminology.md)
- Operation (контракт и модель исполнения): [`10-operation.md`](./10-operation.md)
- Run (жизненный цикл исполнения): [`30-run.md`](./30-run.md)

> Примечание: в v2 термин “Pipeline” считаем legacy. `OperationProfile` — это просто сущность, которая **объединяет набор операций**.

## 0) Scope и допущения

Этот документ:

- описывает `OperationProfile` как **persisted сущность** (БД/JSON — не принципиально);
- задаёт **минимальные правила валидации профиля при сохранении**;
- **не** описывает планирование/исполнение/commit эффектов — это не роль профиля.

## 1) Что такое OperationProfile (в одном абзаце)

**`OperationProfile`** — это **контейнер для набора операций** (идентификатор операции + её `OperationConfig`) и минимальных метаданных (имя/описание/флаги).

Профиль:

- хранится как отдельная сущность в базе;
- используется как входные данные для `Run` (оркестратор читает профиль и запускает операции согласно их конфигам);
- может быть **полностью выключен** флагом `enabled=false` (тогда `Run` считается “без операций” и работает как “чистая генерация main LLM”).

## 2) Составные части: Definition vs Config vs Profile

### 2.1 OperationDefinition (каталог операций)

`OperationDefinition` — “что это за операция” (идентичность + диспетчеризация на handler):

- `operationId` (стабильный)
- `kind`
- `name`, `description?`, `capabilities?` (опционально)

`OperationDefinition` живёт в каталоге (builtin и/или расширяемом) и отдельно от профиля.

### 2.2 OperationConfig (настройка операции в профиле)

`OperationConfig` — “как операция настроена в этом профиле”:

- `enabled`, `required`
- `hooks[]`, `triggers[]?`
- `order`, `dependsOn[]?`
- `params`
- `debug?`

Подробности контракта и исполнения/commit: см. `10-operation.md`.

### 2.3 OperationProfile (композиция)

Профиль **только связывает** `operationId` с `OperationConfig` и хранит их набор как единое целое (без “логики исполнения” внутри профиля).

## 3) Схема данных (минимальная)

Ниже — рекомендуемая минимальная форма. Конкретное хранение (DB/JSON) и ключи могут отличаться, но смысл должен совпадать.

```ts
type OperationProfile = {
  profileId: string; // стабильный идентификатор (например "default", "rp-light", "builtin:story")
  name: string;
  description?: string;

  // Можно выбрать профиль, но полностью выключить его (Run без операций).
  enabled: boolean; // default true

  // Resettable id для привязки persistent-хранилища между run.
  // Пользователь может перегенерировать его, чтобы начать новую “сессию профиля”.
  operationProfileSessionId: string; // например UUID

  // Для миграций/совместимости (рекомендуется):
  version?: number;

  // Набор операций и их конфигурации:
  operations: Array<{
    operationId: string;
    config: OperationConfig;
  }>;
};
```

Рекомендация реализации: для удобства валидации держать быстрый индекс `operationId -> config`, но на уровне контракта это не обязательно.

## 4) Валидация OperationProfile при сохранении (нормативно)

Валидация профиля выполняется **в момент сохранения/обновления** профиля (save‑time validation).

Цели:

- отлавливать очевидно сломанные конфиги заранее;
- гарантировать базовые инварианты v2 (например уникальность `art.<tag>` в рамках профиля).

### 4.1 Валидация структуры

- `profileId` не пустой.
- `enabled` задан и является boolean.
- `operationProfileSessionId` не пустой.
- `operations[]` задан (пустой список допустим, если продукт позволяет “профиль без операций”).
- внутри `operations[]` **нет дубликатов `operationId`**.

### 4.2 Валидация ссылок на OperationDefinition (рекомендуется)

Для каждого `operationId` в профиле рекомендуется проверять, что существует `OperationDefinition` в доступном каталоге (builtin/плагины).

- если определения нет — это **ошибка сохранения** (профиль не должен считаться валидным).

> Примечание: если продукт допускает “черновики профиля” без доступного `OperationDefinition` (например, при импортировании), это должно быть явно описано отдельной политикой.

### 4.3 Валидация `dependsOn` (базовая)

`dependsOn` в `OperationConfig` — это **ссылки по `operationId` внутри того же профиля**.

Базовые правила:

- каждая ссылка в `dependsOn[]` должна указывать на **существующий `operationId`** в этом же `OperationProfile`.
- (рекомендуется) `dependsOn` не должен ссылаться на саму операцию.

Дополнительные проверки (рекомендуется, но могут быть отложены):

- **межхуковые зависимости запрещены**: если `A.config.dependsOn` указывает на `B`, то должно быть возможно, что `A` и `B` выполняются в рамках **одного hook** (в v2 хуки разделены барьером main LLM). Практически это означает, что `dependsOn` не должен “пересекать” хуки. Политика точной проверки зависит от того, допускаем ли мы `hooks[]` с несколькими значениями и как именно оркестратор интерпретирует такие конфиги.
- **циклы зависимостей**: проверка ацикличности (DAG) полезна, но статус этой проверки **TBD** (обсудим позже).

### 4.4 Валидация `order` (базовая)

- `order` обязателен и должен быть числом.

Диапазоны/шаги `order` не нормируются спекой.

### 4.5 Валидация артефактных коллизий (`art.<tag>`) (нормативно)

В v2 действует правило: **`tag` должен быть уникальным в рамках одного `OperationProfile`**.

Это означает: если две операции в одном профиле потенциально пишут один и тот же `art.<tag>`, это ошибка конфигурации и профиль не должен сохраняться как валидный.

Как валидировать:

- валидатор должен уметь вывести **целевой тег записи** для каждой операции из её конфигурации/определения (например через `OperationDefinition.capabilities` или нормализованное поле в `OperationConfig.params`);
- если целевой `tag` нельзя определить статически — это **не рекомендуется** в v2; такие операции должны **явно декларировать** `tag`, иначе профиль считается невалидным (или “непроверяемым” — если продукт вводит такую категорию).

> Связанный инвариант v2: “одна операция пишет только в один `art.<tag>`”. На уровне профиля это обычно означает, что операция должна явно декларировать единственный `writeArtifactTag` (или эквивалент) в своих параметрах/схеме.

## 5) OperationProfileSession (хранилище между Run)

### 5.1 Что такое OperationProfileSession

**OperationProfileSession** — логическое “хранилище состояния”, которое:

- живёт **между** `Run` (переживает множество запусков);
- используется для хранения/доступа к persisted‑артефактам и их истории, а также любых “между‑run” данных, которые нужны операциям;
- выбирается/создаётся по **ключу сессии**.

### 5.2 Ключ сессии (нормативно)

Сессия однозначно определяется кортежем:

- `chatId`
- `branchId`
- `operationProfileRef` (или эквивалент: `profileId` + версия/источник)
- `operationProfileSessionId` (resettable id из профиля)

Если по такому ключу сессии нет — она создаётся. Если есть — переиспользуется.

### 5.3 Для чего нужен `operationProfileSessionId` (мотивация)

Пользователь может существенно изменить профиль/параметры так, что старые persisted‑артефакты станут семантически несовместимыми.

Решение v2:

- перегенерация `operationProfileSessionId` создаёт **новую** `OperationProfileSession`,
- тем самым “обнуляя” видимость persisted‑состояния/историй для последующих `Run`,
- без удаления старых данных (они остаются привязаны к старой сессии по политике продукта).

## 6) Ошибки профиля и время их обнаружения (рекомендуется)

- **Ошибки профиля (save‑time)**: неизвестный `operationId`, плохие `dependsOn`, коллизии `art.<tag>` и т.п. — должны обнаруживаться **при сохранении** профиля и не допускать сохранения невалидного конфига.
- **Ошибки исполнения (run‑time)**: provider error, template render, parse и т.п. — это уже `OperationRun.status="error"` во время `Run`.

## 7) Пример (схематично)

Профиль “RP basic” (как хранилище):

- хранит список операций (id + config), например:
  - `builtin:is_combat_guard` (hooks=`before_main_llm`, required=true, order=10) → пишет `art.is_combat`
  - `builtin:combat_rag` (hooks=`before_main_llm`, required=false, order=20, dependsOn guard) → может `skipped`
  - `builtin:augmentation_notes` (hooks=`before_main_llm`, required=false, order=30)
  - `builtin:world_state_update` (hooks=`after_main_llm`, required=true, order=10) → пишет `art.world_state`

При сохранении такой профиль валидируется (уникальность `art.*`, корректность ссылок `dependsOn`, структура). Исполнение и планирование относятся к `Run`.



========================================
FILE: 30-run.md
========================================

# v2 — Run (жизненный цикл запуска и граница main LLM)

Этот документ описывает, **что такое Run** в v2, как он выполняется по фазам, как работает **барьер до main LLM**, какие статусы считаются терминальными, и что именно фиксируется как результат запуска.

> Run — это “контейнер выполнения”: один запуск по `trigger` для конкретного текущего хода, внутри которого исполняются операции, один main LLM-вызов, и затем пост-операции.

Связанные документы:

- Термины: [`00-terminology.md`](./00-terminology.md)
- Operation (контракт и модель исполнения): [`10-operation.md`](./10-operation.md)
- Operation / kind=llm (aux LLM): [`11-operation-kind-llm.md`](./11-operation-kind-llm.md)

## 0) Scope и допущения

Этот документ:

- описывает **модель поведения Run**, не привязываясь к конкретной реализации (DB/ORM/очереди);
- опирается на модель `Operation` (хуки, статусы, `required`, `dependsOn`, `order`) из `10-operation.md`;
- считает, что `OperationProfile` (как persisted хранилище операций) и `OperationProfileSession` (persisted состояние между run) описаны в других местах (как отдельные спеки), но **использует их как понятия**:
  - `OperationProfile`: [`20-operation-profile.md`](./20-operation-profile.md)
  - (частично) `OperationProfileSession`: [`20-operation-profile.md`](./20-operation-profile.md)

## 1) Что такое Run (в одном абзаце)

**Run** — это единичный запуск оркестратора по `trigger` (`generate` или `regenerate`) для конкретного чата/ветки/хода.  
Внутри Run:

- исполняются операции `before_main_llm` (возможно параллельно, но с зависимостями),
- если барьер пройден — выполняется **ровно один** `main LLM` вызов,
- затем исполняются операции `after_main_llm`,
- фиксируется итог: статусы, `OperationRun`, применённые эффекты, и (если main LLM выполнялся) созданный/обновлённый `assistant variant`.

## 2) Вход Run (что нужно, чтобы стартовать)

Минимальный набор входных данных для создания Run:

- `trigger`: `"generate" | "regenerate"`
- `chatId`
- `branchId`
- идентификаторы текущего хода:
  - при `generate`: создаётся новый `turn` (новый `userMessageId` / `turnId`), потому что есть новый user input
  - при `regenerate`: используется текущий `turn` (существующий `userMessageId` / `turnId`), но создаётся новый `assistantVariantId` (или резервируется место под него)
- `operationProfileRef` (или уже разрешённый список операций с конфигурацией) — **какие операции и в каких хуках должны участвовать**
- `abortSignal` / `deadlineMs?` (политика отмены/таймлимитов)

Дополнительно (не обязательно для принципа, но полезно):

- `initiator`: кто запустил (user/system)
- `clientRequestId?` (идемпотентность на уровне API)

### 2.1 `OperationProfile` (источник операций)

`Run` получает `operationProfileRef` и по нему оркестратор **загружает `OperationProfile` из БД**.

Ключевой принцип: `OperationProfile` — это **persisted контейнер операций** (конфиг), а не процесс/движок исполнения.

Политика “Run без операций”:

- если профиль не задан / выбран режим “без профиля” → `Run` выполняется как “чистая генерация main LLM” без операций;
- если профиль загружен, но `profile.enabled=false` → `Run` также выполняется как “без операций” (профиль выбран, но выключен).

### 2.2 `OperationProfileSession` (persisted состояние между Run)

Помимо профиля, `Run` работает с persisted состоянием профиля — **`OperationProfileSession`**.

`OperationProfileSession` — это состояние **между** `Run`, с которым работают операции (например persisted‑артефакты `art.<tag>` и их history).

Сессия выбирается/создаётся по ключу:

- `chatId`
- `branchId`
- `operationProfileRef` (или эквивалент идентификации профиля)
- `operationProfileSessionId` (resettable id из `OperationProfile`)

Если по такому ключу сессии нет — она создаётся. Если есть — переиспользуется.

## 3) Выход Run (что считается результатом)

Результат Run включает:

- `runId`
- `status` Run (см. раздел 7)
- `startedAt`, `finishedAt`, `durationMs`
- список `OperationRun[]` для операций, которые были запланированы для этого Run (включая `skipped`)
- сведения о `main LLM`:
  - выполнялся ли он (да/нет),
  - если да — `assistantVariantId` (созданный/обновлённый вариант) и его статус/метаданные (в пределах политики логирования)
- “итоговые эффекты” Run:
  - какие эффекты были применены и в каком порядке (deterministic commit),
  - какие артефакты были созданы/обновлены (persisted) и какие были run_only (если логируется их summary)

## 4) Фазы выполнения Run (high-level алгоритм)

Ниже — нормативная модель v2. Она описывает *порядок фаз* и *инварианты*, а не внутренние детали реализации.

### 4.1 Фаза A — Планирование (planning)

1) Оркестратор определяет набор операций на этот Run:

- по `operationProfileRef` загружает `OperationProfile` из БД (или получает “уже разрешённый” список операций, если Run был создан в таком режиме);
- по ключу сессии загружает/создаёт `OperationProfileSession` (persisted состояние между run);
- фильтрует операции по `enabled`,
- фильтрует по `triggers[]` (если заданы),
- группирует по `hooks` (`before_main_llm` / `after_main_llm`).

2) Для каждой операции создаётся запись “запланировано к выполнению” (минимум: `operationId`, `hook`, `required`, `order`, `dependsOn[]`), чтобы Run был наблюдаемым даже при раннем abort/fail.

### 4.2 Фаза B — Выполнение `before_main_llm` (execute)

Операции `before_main_llm` исполняются согласно правилам:

- операции **могут** выполняться параллельно,
- операция **не стартует**, пока все её `dependsOn` не завершились `done`,
- операция должна завершиться терминальным статусом: `done | skipped | error | aborted`.

### 4.3 Фаза C — Барьер `before_main_llm` (barrier)

После того как все `before_main_llm` операции перешли в терминальный статус, оркестратор проверяет барьер:

- если есть операции `required=true`, завершившиеся **не** `done` → барьер **не пройден** и `main LLM` **не запускается**;
- если барьер пройден → можно запускать `main LLM`.

> Важно: “не пройден барьер” — это не обязательно “катастрофа”. Это нормальная модель управления потоком: обязательная операция перед генерацией не смогла завершиться корректно, значит генерацию запускать нельзя.

### 4.4 Фаза D — Main LLM (core generation)

Если барьер пройден, выполняется **ровно один** `main LLM` вызов для этого Run.

Инварианты:

- `main LLM` использует `effective prompt`, подготовленный из:
  - выбранной chat history,
  - включений артефактов,
  - prompt-time эффектов `before_main_llm`.
- операции **не могут** модифицировать `effective prompt` после старта main LLM (в v2 это запрещено моделью хуков).
- результат `main LLM` фиксируется как **assistant variant** текущего хода (новый или обновлённый, зависит от trigger/режима).

### 4.5 Фаза E — Выполнение `after_main_llm` (execute)

После завершения main LLM выполняются операции `after_main_llm`:

- параллельность допустима, зависимости соблюдаются так же через `dependsOn`,
- операции видят в контексте результат main LLM (selected assistant variant текущего хода),
- операции могут возвращать canonicalization effects для текущего turn и писать артефакты (по правилам v2).

### 4.6 Фаза F — Commit (применение эффектов)

Модель v2 разделяет:

- **execute** (операции “что-то сделали”),
- **commit** (их эффекты применились к канону хода / артефактам / prompt-time данным).

Инварианты commit:

- эффекты операции коммитятся **только если** операция завершилась `status="done"`;
- commit порядок детерминированный: зависимости (`dependsOn`) → `order` → `operationId` (tie-break);
- `skipped/error/aborted` считаются “без эффекта”, даже если операция внутри “успела что-то сделать”.

## 5) Отмена и дедлайны

Run поддерживает отмену:

- если пользователь отменил Run или истёк дедлайн, оркестратор сигнализирует `abortSignal` в:
  - выполняющиеся операции,
  - (если уже запущен) main LLM.

Правила статусов:

- операция, увидевшая отмену, должна завершиться `aborted` (или `error` с кодом `timeout`, если это дедлайн, а не ручная отмена — точная политика задаётся реализацией/спекой ошибок);
- если отмена произошла **до** прохождения барьера, main LLM не стартует;
- если отмена произошла **во время** main LLM, результат main LLM может отсутствовать или быть неполным (зависит от реализации main LLM). В v2 это отражается в статусе Run и в логах main LLM, но не “прячется”.

## 6) Поведение `required` в разных фазах

### 6.1 `required` для `before_main_llm`

- `required=true` означает “без `done` у этой операции запускать main LLM нельзя”.
- если required операция завершилась `error|aborted|skipped` → барьер не пройден → main LLM не стартует.

### 6.2 `required` для `after_main_llm`

- `required=true` означает “Run считается неуспешным, если эта операция не `done`”.
- это **не откатывает** уже выполненный main LLM и уже созданный assistant variant.

## 7) Статус Run (минимальная модель)

Минимальные терминальные статусы Run:

- `done` — Run завершился, main LLM (если должен был стартовать) выполнен, и все required операции завершились `done`.
- `failed` — Run завершился, но:
  - либо барьер `before_main_llm` не пройден из-за required операций,
  - либо main LLM упал/не завершился успешно,
  - либо required операции `after_main_llm` не завершились `done`.
- `aborted` — Run отменён пользователем/системой (или остановлен дедлайном по политике “aborted”).

### 7.1 Типизация `failed` (чтобы UI/аналитика понимали “что именно”)

Чтобы `failed` был объяснимым и машинно‑разбираемым, Run при `status="failed"` обязан указывать **тип провала**:

- `failedType: "before_barrier" | "main_llm" | "after_main_llm"`
  - `before_barrier` — main LLM **не стартовал**, потому что required операция(и) в `before_main_llm` не завершились `done` (барьер не пройден).
  - `main_llm` — main LLM **стартовал**, но завершился ошибкой/отменой по политике, из‑за чего Run считается failed.
  - `after_main_llm` — main LLM завершился, но required операция(и) в `after_main_llm` не завершились `done`, из‑за чего Run считается failed.

Дополнительно (рекомендуется): `failedDetails?: { operationId?: string; errorCode?: string; errorMessage?: string }` (bounded), чтобы UI мог показать “почему”.

> Примечание: статус остаётся `failed` (а не отдельные статусы `blocked/...`), но `failedType` даёт нужную детализацию.

## 8) Наблюдаемость Run (что логируем минимум)

Для объяснимости Run должен оставлять след:

- список операций, которые должны были выполниться, и их `OperationRun.status`;
- “почему main LLM не стартовал” (если не стартовал): какая required операция не `done`, и её ошибка/причина;
- “почему Run failed” (если failed): ошибка main LLM или required post-op;
- bounded summaries для LLM-операций (см. `11-operation-kind-llm.md`).

## 8.1) Run “общается” с фронтом (progress / статусы)

Run обязан быть **наблюдаемым в реальном времени**: по мере выполнения он публикует события о старте/прогрессе/завершении, чтобы UI мог показывать статусы вроде:

- `Operation: написание CoT — в процессе`
- `Operation: создание стат-трекера — завершена успешно`

Требование v2: UI **не должен** вычислять прогресс “по косвенным признакам”; оркестратор обязан явно сообщать изменения состояния.

Минимальная модель событий (без привязки к транспорту: SSE/WebSocket/long-poll — отдельно):

- `run.started` — Run создан и принят в исполнение
- `run.phase_changed` — смена фазы (`planning | before_main_llm | barrier | main_llm | after_main_llm | commit | finished`)
- `operation.started` — конкретная операция начала выполнение
- `operation.finished` — операция завершилась терминальным статусом (`done|skipped|error|aborted`)
- `main_llm.started` / `main_llm.finished` — старт/завершение main LLM (успех/ошибка/отмена, с различением причин)
- `run.finished` — Run завершён терминальным статусом (`done|failed|aborted`, и при `failed` — с `failedType`)

Минимальные поля, нужные UI в событиях:

- **идентификация**: `runId`, `chatId`, `turnId/userMessageId`, `trigger`, `hook?`, `operationId?`
- **человекочитаемое имя операции**: `operationName` (опционально) и/или `operationId` для маппинга на UI
- **статус/фаза**: `phase`, `status`
- **время**: `ts` (timestamp события) или `startedAt/finishedAt`
- **ошибка (если есть)**: `error.code`, `error.message` (bounded)

Правило v2 для UI-имён:

- `operationName`, если передаётся, **всегда равен** `OperationDefinition.name` (никаких runtime-имен/динамических заголовков).
- если `operationName` не передаётся, UI получает имя через маппинг по `operationId` (из каталога `OperationDefinition`).

Принцип: эти события описывают **процесс исполнения** (execute/progress), а не “коммит эффектов”. Эффекты считаются применёнными только по правилам commit из `10-operation.md`.

### 8.1.1 Порядок событий (ordering) и идемпотентность (важно для UI)

“Порядок” здесь — это не про логику исполнения (она у нас детерминируема), а про доставку событий на клиент.

Минимальные требования v2:

- каждое событие имеет `seq: number` — монотонно возрастающий номер события **в рамках одного `runId`** (начиная с 1);
- клиент может безопасно:
  - получать дубликаты (например при переподключении) и дедуплицировать по (`runId`,`seq`),
  - получить события “в другом порядке”, чем они были сгенерированы, и отсортировать по `seq`.

Почему “`operation.finished` могло прийти раньше `operation.started`” вообще возможно:

- переподключение UI к стриму: сервер может сначала отдать “догоняющие” последние события/снапшот, а потом продолжить live‑стрим;
- разные каналы доставки (например отдельные источники событий для run/ops) и их буферизация;
- повторная доставка (replay) при ошибках транспорта.

Нормативно: **с точки зрения оркестратора** `operation.started` генерируется раньше `operation.finished` для одной операции, но UI не должен зависеть от сетевого порядка — он должен опираться на `seq`.

### 8.1.2 Различение причин завершения main LLM (успех/ошибка/отмена)

Событие `main_llm.finished` обязано различать “почему закончилось”, чтобы UI мог показывать корректные статусы.

Минимальные поля:

- `status: "done" | "error" | "aborted"`
- `finishReason: "completed" | "user_abort" | "deadline" | "provider_error" | "rate_limited" | "timeout" | "policy_error" | "unknown"`
- `error?: { code: string; message: string }` (bounded) — если `status="error"`

Аналогично, `run.finished` при `status="failed"` должен включать `failedType` из раздела 7.1.

## 9) Инварианты v2 (короткий чек-лист)

- В каждом Run выполняется **ровно один** `main LLM` вызов, либо ни одного (если барьер не пройден/abort).
- `before_main_llm` влияет на генерацию **только** через prompt-time эффекты и подготовку данных.
- Операции не переписывают прошлое: только текущий turn и артефакты.
- Эффекты применяются **только** при `status="done"` и детерминированно.


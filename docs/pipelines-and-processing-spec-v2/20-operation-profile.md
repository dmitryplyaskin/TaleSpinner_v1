# v2 — OperationProfile (профиль операций)

Этот документ описывает, **что такое OperationProfile** в v2, как он устроен, как валидируется, и как используется оркестратором при создании `Run`.

Связанные документы:

- Термины: [`00-terminology.md`](./00-terminology.md)
- Operation (контракт и модель исполнения): [`10-operation.md`](./10-operation.md)
- Run: [`30-run.md`](./30-run.md)

> Примечание: в v2 термин “Pipeline” считаем legacy. `OperationProfile` — это конфиг “какие операции запускать”, а не конвейер шагов.

## 0) Scope и допущения

Этот документ:

- фиксирует **конфигурационную** сущность `OperationProfile` (не выполнение);
- задаёт минимальную схему и правила валидации, достаточные, чтобы оркестратор мог построить план выполнения;
- не описывает транспорт событий, схему `OperationEffects`, модель prompt building и persistence артефактов — они живут в других спеках.

## 1) Что такое OperationProfile (в одном абзаце)

**OperationProfile** — это **набор включённых `Operation` и их конфигураций** (`OperationConfig`), который отвечает на вопрос:

- какие операции должны участвовать в `Run`,
- в каких `hook` (`before_main_llm` / `after_main_llm`),
- при каких `trigger` (`generate` / `regenerate`),
- в каком порядке (через `order`) и с какими зависимостями (`dependsOn`),
- с какими параметрами исполнения (`params`).

Профиль — это **конфиг** (read-only во время `Run`), а фактическое выполнение логируется как `Run` и `OperationRun`.

### 1.1 Идентификатор “сессии профиля” (живёт между Run)

Иногда пользователь делает **существенные изменения** в профиле (или его параметрах), после чего ранее накопленные данные (артефакты, их история, промежуточные результаты) могут стать **семантически несовместимыми** с новой логикой.

Для этого v2 вводит **`operationProfileSessionId`** — пользовательский “resettable id” профиля:

- генерируется (например UUID) при создании профиля или при первом применении;
- **стабилен до тех пор, пока пользователь сам его не перегенерирует**;
- является частью ключа “хранилища между run” (см. 6.6), чтобы можно было “начать заново” без удаления данных вручную.

## 2) Роль OperationProfile в Run

На вход `Run` приходит `operationProfileRef` (или уже разрешённый/вшитый список операций).
Оркестратор делает:

1) Загружает профиль по `operationProfileRef`.
2) Делает **resolution** профиля в “план операций для этого Run”:
   - фильтрация `enabled`,
   - фильтрация по `triggers[]` (если задано),
   - разворачивание по `hooks[]`,
   - формирование графа зависимостей и очереди commit.
3) Создаёт `OperationRun` записи “запланировано”, чтобы Run был наблюдаемым даже при раннем abort/fail.

Важно:

- `OperationProfile` не описывает main LLM. Main LLM — отдельный процесс Run.
- `OperationProfile` не определяет “как применять эффекты”; он только определяет, **какие операции и в каком порядке их эффекты будут коммититься** (через `order/dependsOn`).

## 3) Составные части: Definition vs Config vs Profile

### 3.1 OperationDefinition (каталог операций)

`OperationDefinition` — это “что это за операция” (идентичность + диспетчеризация на handler):

- `operationId` (стабильный)
- `kind`
- `name`, `description?`, `capabilities?` (опционально)

`OperationDefinition` живёт в каталоге (builtin и/или расширяемом) и отдельно от профиля.

### 3.2 OperationConfig (настройка операции в профиле)

`OperationConfig` — это “как именно операция настроена в этом профиле”:

- `enabled`, `required`
- `hooks[]`, `triggers[]?`
- `order`, `dependsOn[]?`
- `params`
- `debug?`

Подробности и модель исполнения/commit: см. `10-operation.md`.

### 3.3 OperationProfile (композиция)

Профиль связывает `operationId` с соответствующим `OperationConfig` и делает из набора операций единый согласованный план.

## 4) Схема данных (минимальная)

Ниже — рекомендуемая минимальная форма. Конкретное хранение (DB/JSON) и ключи могут отличаться, но смысл должен совпадать.

```ts
type OperationProfile = {
  profileId: string; // стабильный идентификатор (например "default", "rp-light", "builtin:story")
  name: string;
  description?: string;

  // Resettable id для привязки persistent-хранилища между run.
  // Пользователь может перегенерировать его, чтобы начать новую “сессию профиля”.
  operationProfileSessionId: string; // например UUID

  // Для миграций/совместимости (рекомендуется):
  version?: number;

  // Набор операций и их конфигурации:
  operations: Array<{
    operationId: string;
    config: OperationConfig;
  }>;
};
```

Рекомендация реализации: для удобства валидации и резолва держать внутри профиля быстрый индекс `operationId -> config`, но на уровне контракта это не обязательно.

## 5) Resolution профиля в “план операций для Run”

`OperationProfile` сам по себе не знает “какой сейчас trigger/hook”.
Поэтому перед исполнением его нужно “разрешить” для конкретного `Run` в список задач.

### 5.1 Вход резолва

- `profile: OperationProfile`
- `trigger: "generate" | "regenerate"`

### 5.2 Выход резолва (концептуально)

Результат резолва — это список “запланированных операций” (для логов и исполнения), где каждая запись однозначно соответствует одному `OperationRun`.

```ts
type PlannedOperation = {
  operationId: string;
  hook: "before_main_llm" | "after_main_llm";
  required: boolean;
  order: number;
  dependsOn: string[]; // по operationId (в рамках того же hook)
  params: Record<string, unknown>;
  debug?: { enabled?: boolean };
};
```

### 5.3 Правила резолва (нормативно)

- **enabled**:
  - если `enabled=false`, операция не попадает в план.
- **triggers**:
  - если `triggers[]` не задано — операция применима к любому trigger;
  - если задано — операция попадает в план только если `trigger` входит в список.
- **hooks**:
  - если `hooks` содержит несколько значений, в план попадает **несколько** `PlannedOperation` с одинаковым `operationId`, но разными `hook`.
  - (рекомендация) Валидацией можно запретить несколько хуков для одной операции, если это усложняет логику; но v2 модель это не требует.
- **dependsOn**:
  - `dependsOn` задаётся через `operationId`;
  - зависимость должна ссылаться на операцию, которая также присутствует в плане **в том же hook**.
    - если зависимость указывает на операцию другого hook, это считается ошибкой конфигурации (см. 6.3).

## 6) Валидация OperationProfile (нормативно)

### 6.1 Валидация структуры

- `profileId` не пустой.
- `operationProfileSessionId` не пустой.
- `operations[]` не пустой (или допускается пустой профиль — зависит от продукта, но v2 модель допускает “без операций”).
- внутри `operations[]` **нет дубликатов `operationId`**.

### 6.2 Валидация ссылок на OperationDefinition

Для каждого `operationId` в профиле должен существовать `OperationDefinition` в доступном каталоге (builtin/плагины).
Если определения нет — это **ошибка конфигурации** (профиль не может быть применён).

### 6.3 Валидация графа зависимостей

Валидация проводится **на уровне каждого hook отдельно** (потому что хуки разделены барьером main LLM).

Правила:

- `dependsOn` не может ссылаться на несуществующую/отфильтрованную (disabled/trigger mismatch) операцию.
- `dependsOn` не может ссылаться на операцию из другого hook.
- граф зависимостей должен быть **ацикличным** (DAG). Цикл — ошибка конфигурации.
- (рекомендуется) `dependsOn` не должен ссылаться на саму операцию.

### 6.4 Валидация `order`

- `order` обязателен и должен быть числом.
- (рекомендуется) диапазон/шаги `order` не нормируются спекой; это ответственность автора профиля.

### 6.5 Валидация артефактных коллизий (по `art.<tag>`)

В v2 действует правило: **`tag` должен быть уникальным в рамках одного OperationProfile**.

Это означает: если две операции в одном профиле (в любой фазе) потенциально пишут один и тот же `art.<tag>`, это считается ошибкой конфигурации.

Как проверять:

- если `OperationDefinition.capabilities` или `OperationConfig.params` позволяют вывести “куда пишет операция” (например `kind="llm"` имеет `params.writeArtifact.tag`) — валидатор должен собирать список target tags и проверять уникальность;
- если tag не выводим статически (например операция вычисляет его динамически) — это **не рекомендуется** в v2; такие операции должны декларировать tag явно, иначе профиль считается невалидным (или “валидным, но непроверяемым” — политика реализации).

> Примечание: допущение v2 — конфигурация профиля должна быть настолько явной, чтобы система могла обнаруживать коллизии до исполнения.

## 6.6 OperationProfileSession (хранилище между Run)

### 6.6.1 Что такое OperationProfileSession

**OperationProfileSession** — это логическое “хранилище состояния”, которое:

- живёт **между** `Run` (переживает множество запусков);
- используется для хранения/доступа к persisted‑артефактам и их истории, а также любых “между‑run” данных, которые нужны операциям;
- выбирается/создаётся по **ключу сессии**.

### 6.6.2 Ключ сессии (нормативно)

Сессия однозначно определяется кортежем:

- `chatId`
- `branchId?` (если ветвление поддерживается)
- `operationProfileRef` (или эквивалент: `profileId` + версия/источник)
- `operationProfileSessionId` (resettable id из профиля)

Если по такому ключу сессии нет — она создаётся. Если есть — переиспользуется.

### 6.6.3 Для чего нужен `operationProfileSessionId` (мотивация)

Пользователь может:

- существенно изменить логику профиля (например Liquid‑шаблон, условия вроде `if history length > 0`, формат JSON, парсинг),
- и при этом не хотеть “тащить” старую историю/старые значения артефактов в новую логику.

Решение v2:

- перегенерация `operationProfileSessionId` создаёт **новую** `OperationProfileSession`,
- тем самым “обнуляя” видимость persisted‑состояния/историй для последующих `Run`,
- без удаления старых данных (они остаются привязанными к старой сессии и могут быть доступны для дебага/отката по политике продукта).

## 7) Ошибки профиля и время их обнаружения

Рекомендуемая политика:

- **Статические ошибки профиля** (не найден `OperationDefinition`, циклы, bad dependsOn, коллизии `art.<tag>`) должны обнаруживаться **до создания Run** (или при создании Run, но до старта выполнения), чтобы UI мог сразу показать “конфиг сломан”.
- Ошибки выполнения (provider error, template render, output parse) — это уже `OperationRun.status="error"` во время `Run`.

## 8) Пример (схематично)

Профиль “RP basic”:

- `before_main_llm`:
  - guard `builtin:is_combat_guard` (required=true, order=10) → пишет `art.is_combat` (run_only)
  - `builtin:combat_rag` (required=false, order=20, dependsOn guard) → может `skipped`
  - `builtin:augmentation_notes` (required=false, order=30) → prompt-time вставка
- `after_main_llm`:
  - `builtin:world_state_update` (required=true, order=10) → пишет `art.world_state` (persisted)

В таком профиле `dependsOn` обеспечивает, что `combat_rag` видит guard-флаг, а `required=true` на guard блокирует запуск main LLM, если guard не смог завершиться `done`.


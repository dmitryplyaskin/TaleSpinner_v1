# v2 — Run (жизненный цикл запуска и граница main LLM)

Этот документ описывает, **что такое Run** в v2, как он выполняется по фазам, как работает **барьер до main LLM**, какие статусы считаются терминальными, и что именно фиксируется как результат запуска.

> Run — это “контейнер выполнения”: один запуск по `trigger` для конкретного текущего хода, внутри которого исполняются операции, один main LLM-вызов, и затем пост-операции.

Связанные документы:

- Термины: [`00-terminology.md`](./00-terminology.md)
- Operation (контракт и модель исполнения): [`10-operation.md`](./10-operation.md)
- Operation / kind=llm (aux LLM): [`11-operation-kind-llm.md`](./11-operation-kind-llm.md)

## 0) Scope и допущения

Этот документ:

- описывает **модель поведения Run**, не привязываясь к конкретной реализации (DB/ORM/очереди);
- опирается на модель `Operation` (хуки, статусы, `required`, `dependsOn`, `order`) из `10-operation.md`;
- считает, что `OperationProfile` (как persisted хранилище операций) и `OperationProfileSession` (persisted состояние между run) описаны в других местах (как отдельные спеки), но **использует их как понятия**:
  - `OperationProfile`: [`20-operation-profile.md`](./20-operation-profile.md)
  - (частично) `OperationProfileSession`: [`20-operation-profile.md`](./20-operation-profile.md)

## 1) Что такое Run (в одном абзаце)

**Run** — это единичный запуск оркестратора по `trigger` (`generate` или `regenerate`) для конкретного чата/ветки/хода.  
Внутри Run:

- исполняются операции `before_main_llm` (возможно параллельно, но с зависимостями),
- если барьер пройден — выполняется **ровно один** `main LLM` вызов,
- затем исполняются операции `after_main_llm`,
- фиксируется итог: статусы, `OperationRun`, применённые эффекты, и (если main LLM выполнялся) созданный/обновлённый `assistant variant`.

## 2) Вход Run (что нужно, чтобы стартовать)

Минимальный набор входных данных для создания Run:

- `trigger`: `"generate" | "regenerate"`
- `chatId`
- `branchId`
- идентификаторы текущего хода:
  - при `generate`: создаётся новый `turn` (новый `userMessageId` / `turnId`), потому что есть новый user input
  - при `regenerate`: используется текущий `turn` (существующий `userMessageId` / `turnId`), но создаётся новый `assistantVariantId` (или резервируется место под него)
- `operationProfileRef` (или уже разрешённый список операций с конфигурацией) — **какие операции и в каких хуках должны участвовать**
- `abortSignal` / `deadlineMs?` (политика отмены/таймлимитов)

Дополнительно (не обязательно для принципа, но полезно):

- `initiator`: кто запустил (user/system)
- `clientRequestId?` (идемпотентность на уровне API)

### 2.1 `OperationProfile` (источник операций)

`Run` получает `operationProfileRef` и по нему оркестратор **загружает `OperationProfile` из БД**.

Ключевой принцип: `OperationProfile` — это **persisted контейнер операций** (конфиг), а не процесс/движок исполнения.

Политика “Run без операций”:

- если профиль не задан / выбран режим “без профиля” → `Run` выполняется как “чистая генерация main LLM” без операций;
- если профиль загружен, но `profile.enabled=false` → `Run` также выполняется как “без операций” (профиль выбран, но выключен).

### 2.2 `OperationProfileSession` (persisted состояние между Run)

Помимо профиля, `Run` работает с persisted состоянием профиля — **`OperationProfileSession`**.

`OperationProfileSession` — это состояние **между** `Run`, с которым работают операции (например persisted‑артефакты `art.<tag>` и их history).

Сессия выбирается/создаётся по ключу:

- `chatId`
- `branchId`
- `operationProfileRef` (или эквивалент идентификации профиля)
- `operationProfileSessionId` (resettable id из `OperationProfile`)

Если по такому ключу сессии нет — она создаётся. Если есть — переиспользуется.

## 3) Выход Run (что считается результатом)

Результат Run включает:

- `runId`
- `status` Run (см. раздел 7)
- `startedAt`, `finishedAt`, `durationMs`
- список `OperationRun[]` для операций, которые были запланированы для этого Run (включая `skipped`)
- сведения о `main LLM`:
  - выполнялся ли он (да/нет),
  - если да — `assistantVariantId` (созданный/обновлённый вариант) и его статус/метаданные (в пределах политики логирования)
- “итоговые эффекты” Run:
  - какие эффекты были применены и в каком порядке (deterministic commit),
  - какие артефакты были созданы/обновлены (persisted) и какие были run_only (если логируется их summary)

## 4) Фазы выполнения Run (high-level алгоритм)

Ниже — нормативная модель v2. Она описывает *порядок фаз* и *инварианты*, а не внутренние детали реализации.

### 4.1 Фаза A — Планирование (planning)

1) Оркестратор определяет набор операций на этот Run:

- по `operationProfileRef` загружает `OperationProfile` из БД (или получает “уже разрешённый” список операций, если Run был создан в таком режиме);
- по ключу сессии загружает/создаёт `OperationProfileSession` (persisted состояние между run);
- фильтрует операции по `enabled`,
- фильтрует по `triggers[]` (если заданы),
- группирует по `hooks` (`before_main_llm` / `after_main_llm`).

2) Для каждой операции создаётся запись “запланировано к выполнению” (минимум: `operationId`, `hook`, `required`, `order`, `dependsOn[]`), чтобы Run был наблюдаемым даже при раннем abort/fail.

### 4.2 Фаза B — Выполнение `before_main_llm` (execute)

Операции `before_main_llm` исполняются согласно правилам:

- операции **могут** выполняться параллельно,
- операция **не стартует**, пока все её `dependsOn` не завершились `done`,
- операция должна завершиться терминальным статусом: `done | skipped | error | aborted`.

### 4.3 Фаза C — Барьер `before_main_llm` (barrier)

После того как все `before_main_llm` операции перешли в терминальный статус, оркестратор проверяет барьер:

- если есть операции `required=true`, завершившиеся **не** `done` → барьер **не пройден** и `main LLM` **не запускается**;
- если барьер пройден → можно запускать `main LLM`.

> Важно: “не пройден барьер” — это не обязательно “катастрофа”. Это нормальная модель управления потоком: обязательная операция перед генерацией не смогла завершиться корректно, значит генерацию запускать нельзя.

### 4.4 Фаза D — Main LLM (core generation)

Если барьер пройден, выполняется **ровно один** `main LLM` вызов для этого Run.

Инварианты:

- `main LLM` использует `effective prompt`, подготовленный из:
  - выбранной chat history,
  - включений артефактов,
  - prompt-time эффектов `before_main_llm`.
- операции **не могут** модифицировать `effective prompt` после старта main LLM (в v2 это запрещено моделью хуков).
- результат `main LLM` фиксируется как **assistant variant** текущего хода (новый или обновлённый, зависит от trigger/режима).

### 4.5 Фаза E — Выполнение `after_main_llm` (execute)

После завершения main LLM выполняются операции `after_main_llm`:

- параллельность допустима, зависимости соблюдаются так же через `dependsOn`,
- операции видят в контексте результат main LLM (selected assistant variant текущего хода),
- операции могут возвращать canonicalization effects для текущего turn и писать артефакты (по правилам v2).

### 4.6 Фаза F — Commit (применение эффектов)

Модель v2 разделяет:

- **execute** (операции “что-то сделали”),
- **commit** (их эффекты применились к канону хода / артефактам / prompt-time данным).

Инварианты commit:

- эффекты операции коммитятся **только если** операция завершилась `status="done"`;
- commit порядок детерминированный: зависимости (`dependsOn`) → `order` → `operationId` (tie-break);
- `skipped/error/aborted` считаются “без эффекта”, даже если операция внутри “успела что-то сделать”.

## 5) Отмена и дедлайны

Run поддерживает отмену:

- если пользователь отменил Run или истёк дедлайн, оркестратор сигнализирует `abortSignal` в:
  - выполняющиеся операции,
  - (если уже запущен) main LLM.

Правила статусов:

- операция, увидевшая отмену, должна завершиться `aborted` (или `error` с кодом `timeout`, если это дедлайн, а не ручная отмена — точная политика задаётся реализацией/спекой ошибок);
- если отмена произошла **до** прохождения барьера, main LLM не стартует;
- если отмена произошла **во время** main LLM, результат main LLM может отсутствовать или быть неполным (зависит от реализации main LLM). В v2 это отражается в статусе Run и в логах main LLM, но не “прячется”.

## 6) Поведение `required` в разных фазах

### 6.1 `required` для `before_main_llm`

- `required=true` означает “без `done` у этой операции запускать main LLM нельзя”.
- если required операция завершилась `error|aborted|skipped` → барьер не пройден → main LLM не стартует.

### 6.2 `required` для `after_main_llm`

- `required=true` означает “Run считается неуспешным, если эта операция не `done`”.
- это **не откатывает** уже выполненный main LLM и уже созданный assistant variant.

## 7) Статус Run (минимальная модель)

Минимальные терминальные статусы Run:

- `done` — Run завершился, main LLM (если должен был стартовать) выполнен, и все required операции завершились `done`.
- `failed` — Run завершился, но:
  - либо барьер `before_main_llm` не пройден из-за required операций,
  - либо main LLM упал/не завершился успешно,
  - либо required операции `after_main_llm` не завершились `done`.
- `aborted` — Run отменён пользователем/системой (или остановлен дедлайном по политике “aborted”).

### 7.1 Типизация `failed` (чтобы UI/аналитика понимали “что именно”)

Чтобы `failed` был объяснимым и машинно‑разбираемым, Run при `status="failed"` обязан указывать **тип провала**:

- `failedType: "before_barrier" | "main_llm" | "after_main_llm"`
  - `before_barrier` — main LLM **не стартовал**, потому что required операция(и) в `before_main_llm` не завершились `done` (барьер не пройден).
  - `main_llm` — main LLM **стартовал**, но завершился ошибкой/отменой по политике, из‑за чего Run считается failed.
  - `after_main_llm` — main LLM завершился, но required операция(и) в `after_main_llm` не завершились `done`, из‑за чего Run считается failed.

Дополнительно (рекомендуется): `failedDetails?: { operationId?: string; errorCode?: string; errorMessage?: string }` (bounded), чтобы UI мог показать “почему”.

> Примечание: статус остаётся `failed` (а не отдельные статусы `blocked/...`), но `failedType` даёт нужную детализацию.

## 8) Наблюдаемость Run (что логируем минимум)

Для объяснимости Run должен оставлять след:

- список операций, которые должны были выполниться, и их `OperationRun.status`;
- “почему main LLM не стартовал” (если не стартовал): какая required операция не `done`, и её ошибка/причина;
- “почему Run failed” (если failed): ошибка main LLM или required post-op;
- bounded summaries для LLM-операций (см. `11-operation-kind-llm.md`).

## 8.1) Run “общается” с фронтом (progress / статусы)

Run обязан быть **наблюдаемым в реальном времени**: по мере выполнения он публикует события о старте/прогрессе/завершении, чтобы UI мог показывать статусы вроде:

- `Operation: написание CoT — в процессе`
- `Operation: создание стат-трекера — завершена успешно`

Требование v2: UI **не должен** вычислять прогресс “по косвенным признакам”; оркестратор обязан явно сообщать изменения состояния.

Минимальная модель событий (без привязки к транспорту: SSE/WebSocket/long-poll — отдельно):

- `run.started` — Run создан и принят в исполнение
- `run.phase_changed` — смена фазы (`planning | before_main_llm | barrier | main_llm | after_main_llm | commit | finished`)
- `operation.started` — конкретная операция начала выполнение
- `operation.finished` — операция завершилась терминальным статусом (`done|skipped|error|aborted`)
- `main_llm.started` / `main_llm.finished` — старт/завершение main LLM (успех/ошибка/отмена, с различением причин)
- `run.finished` — Run завершён терминальным статусом (`done|failed|aborted`, и при `failed` — с `failedType`)

Минимальные поля, нужные UI в событиях:

- **идентификация**: `runId`, `chatId`, `turnId/userMessageId`, `trigger`, `hook?`, `operationId?`
- **человекочитаемое имя операции**: `operationName` (опционально) и/или `operationId` для маппинга на UI
- **статус/фаза**: `phase`, `status`
- **время**: `ts` (timestamp события) или `startedAt/finishedAt`
- **ошибка (если есть)**: `error.code`, `error.message` (bounded)

Правило v2 для UI-имён:

- `operationName`, если передаётся, **всегда равен** `OperationDefinition.name` (никаких runtime-имен/динамических заголовков).
- если `operationName` не передаётся, UI получает имя через маппинг по `operationId` (из каталога `OperationDefinition`).

Принцип: эти события описывают **процесс исполнения** (execute/progress), а не “коммит эффектов”. Эффекты считаются применёнными только по правилам commit из `10-operation.md`.

### 8.1.1 Порядок событий (ordering) и идемпотентность (важно для UI)

“Порядок” здесь — это не про логику исполнения (она у нас детерминируема), а про доставку событий на клиент.

Минимальные требования v2:

- каждое событие имеет `seq: number` — монотонно возрастающий номер события **в рамках одного `runId`** (начиная с 1);
- клиент может безопасно:
  - получать дубликаты (например при переподключении) и дедуплицировать по (`runId`,`seq`),
  - получить события “в другом порядке”, чем они были сгенерированы, и отсортировать по `seq`.

Почему “`operation.finished` могло прийти раньше `operation.started`” вообще возможно:

- переподключение UI к стриму: сервер может сначала отдать “догоняющие” последние события/снапшот, а потом продолжить live‑стрим;
- разные каналы доставки (например отдельные источники событий для run/ops) и их буферизация;
- повторная доставка (replay) при ошибках транспорта.

Нормативно: **с точки зрения оркестратора** `operation.started` генерируется раньше `operation.finished` для одной операции, но UI не должен зависеть от сетевого порядка — он должен опираться на `seq`.

### 8.1.2 Различение причин завершения main LLM (успех/ошибка/отмена)

Событие `main_llm.finished` обязано различать “почему закончилось”, чтобы UI мог показывать корректные статусы.

Минимальные поля:

- `status: "done" | "error" | "aborted"`
- `finishReason: "completed" | "user_abort" | "deadline" | "provider_error" | "rate_limited" | "timeout" | "policy_error" | "unknown"`
- `error?: { code: string; message: string }` (bounded) — если `status="error"`

Аналогично, `run.finished` при `status="failed"` должен включать `failedType` из раздела 7.1.

## 9) Инварианты v2 (короткий чек-лист)

- В каждом Run выполняется **ровно один** `main LLM` вызов, либо ни одного (если барьер не пройден/abort).
- `before_main_llm` влияет на генерацию **только** через prompt-time эффекты и подготовку данных.
- Операции не переписывают прошлое: только текущий turn и артефакты.
- Эффекты применяются **только** при `status="done"` и детерминированно.


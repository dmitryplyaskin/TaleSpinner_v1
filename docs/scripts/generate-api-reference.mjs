import {existsSync} from 'node:fs';
import {readdir, readFile, writeFile, mkdir} from 'node:fs/promises';
import path from 'node:path';
import {fileURLToPath} from 'node:url';

const thisFile = fileURLToPath(import.meta.url);
const scriptsDir = path.dirname(thisFile);
const docsRoot = path.resolve(scriptsDir, '..');
const repoRoot = path.resolve(docsRoot, '..');
const apiRoot = path.join(repoRoot, 'server', 'src', 'api');
const routesRegistryPath = path.join(apiRoot, '_routes_.ts');

const outRuPath = path.join(docsRoot, 'docs', 'dev', 'backend', 'api-endpoints.md');
const outEnPath = path.join(docsRoot, 'i18n', 'en', 'docusaurus-plugin-content-docs', 'current', 'dev', 'backend', 'api-endpoints.md');

async function walkFiles(dir) {
  const entries = await readdir(dir, {withFileTypes: true});
  const files = [];
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...(await walkFiles(fullPath)));
      continue;
    }
    files.push(fullPath);
  }
  return files;
}

function toPosix(filePath) {
  return filePath.split(path.sep).join('/');
}

function resolveImportTs(baseFile, importPath) {
  const baseResolved = path.resolve(path.dirname(baseFile), importPath);
  const directTs = `${baseResolved}.ts`;
  if (existsSync(directTs)) return path.normalize(directTs);
  const indexTs = path.join(baseResolved, 'index.ts');
  if (existsSync(indexTs)) return path.normalize(indexTs);
  return path.normalize(baseResolved);
}

function buildLineStarts(text) {
  const starts = [0];
  for (let i = 0; i < text.length; i += 1) {
    if (text[i] === '\n') starts.push(i + 1);
  }
  return starts;
}

function lineForIndex(lineStarts, index) {
  let low = 0;
  let high = lineStarts.length - 1;
  while (low <= high) {
    const mid = Math.floor((low + high) / 2);
    if (lineStarts[mid] <= index) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  return high + 1;
}

function normalizeRoutePath(rawPath) {
  if (!rawPath) return '/';
  return rawPath.startsWith('/') ? rawPath : `/${rawPath}`;
}

function parseEndpointsFromFile(filePath, text, mountedInApiPrefix) {
  const endpoints = [];
  const lineStarts = buildLineStarts(text);

  const directRegex = /router\.(get|post|put|patch|delete|all|use)\(\s*(?:\r?\n\s*)*(['"`])([^'"`]+)\2/g;
  for (const match of text.matchAll(directRegex)) {
    const method = String(match[1]).toUpperCase();
    const rawPath = String(match[3]);
    const line = lineForIndex(lineStarts, match.index ?? 0);
    const routePath = normalizeRoutePath(rawPath);
    const fullPath = mountedInApiPrefix ? `/api${routePath}` : routePath;
    endpoints.push({method, fullPath, line});
  }

  const chainRegex = /router\.route\(\s*(?:\r?\n\s*)*(['"`])([^'"`]+)\1\s*\)([\s\S]*?);/g;
  for (const chainMatch of text.matchAll(chainRegex)) {
    const rawPath = String(chainMatch[2]);
    const chainBody = String(chainMatch[3] ?? '');
    const chainStart = (chainMatch.index ?? 0) + chainMatch[0].indexOf(chainBody);
    const methodRegex = /\.(get|post|put|patch|delete|all|use)\s*\(/g;
    for (const methodMatch of chainBody.matchAll(methodRegex)) {
      const method = String(methodMatch[1]).toUpperCase();
      const localIndex = methodMatch.index ?? 0;
      const line = lineForIndex(lineStarts, chainStart + localIndex);
      const routePath = normalizeRoutePath(rawPath);
      const fullPath = mountedInApiPrefix ? `/api${routePath}` : routePath;
      endpoints.push({method, fullPath, line});
    }
  }

  return endpoints;
}

function renderRuMarkdown(rows) {
  const tableRows = rows
    .map((row) => `| ${row.method} | ${row.path} | \`${row.source}\` | ${row.handler} |`)
    .join('\n');

  return `---
title: API Endpoints
sidebar_position: 2
description: Автогенерируемый инвентарь backend endpoint-ов из server/src/api.
---

# API Endpoints

Этот файл генерируется скриптом \`docs/scripts/generate-api-reference.mjs\`.

Источники:

- \`server/src/api/_routes_.ts\`
- \`server/src/api/**/*.ts\`

## Endpoint inventory

| Method | Path | Source file | Handler section |
| --- | --- | --- | --- |
${tableRows}

## Notes

- Для роутов из \`_routes_.ts\` путь нормализуется с префиксом \`/api\`.
- Для router chaining (\`router.route(...).get(...).delete(...)\`) каждый метод включается отдельно.
`;
}

function renderEnMarkdown(rows) {
  const tableRows = rows
    .map((row) => `| ${row.method} | ${row.path} | \`${row.source}\` | ${row.handler} |`)
    .join('\n');

  return `---
title: API Endpoints
sidebar_position: 2
description: Auto-generated backend endpoint inventory from server/src/api.
---

# API Endpoints

This file is generated by \`docs/scripts/generate-api-reference.mjs\`.

Sources:

- \`server/src/api/_routes_.ts\`
- \`server/src/api/**/*.ts\`

## Endpoint inventory

| Method | Path | Source file | Handler section |
| --- | --- | --- | --- |
${tableRows}

## Notes

- Routes included in \`_routes_.ts\` are normalized with the \`/api\` prefix.
- For router chaining (\`router.route(...).get(...).delete(...)\`), each method is emitted as a separate row.
`;
}

async function main() {
  const registryText = await readFile(routesRegistryPath, 'utf8');

  const importMap = new Map();
  const importRegex = /import\s+([A-Za-z_$][\w$]*)\s+from\s+"(.+?)";/g;
  for (const match of registryText.matchAll(importRegex)) {
    const varName = String(match[1]);
    const importPath = String(match[2]);
    importMap.set(varName, resolveImportTs(routesRegistryPath, importPath));
  }

  const routesBodyMatch = registryText.match(/export const routes = \[([\s\S]*?)\];/);
  const mountedRouteVars = new Set();
  if (routesBodyMatch?.[1]) {
    const listBody = routesBodyMatch[1];
    for (const varMatch of listBody.matchAll(/\b([A-Za-z_$][\w$]*)\b/g)) {
      const id = String(varMatch[1]);
      if (importMap.has(id)) mountedRouteVars.add(id);
    }
  }

  const mountedFiles = new Set(
    Array.from(mountedRouteVars).map((id) => path.normalize(importMap.get(id)))
  );

  const apiFiles = (await walkFiles(apiRoot))
    .filter((filePath) => filePath.endsWith('.ts'))
    .filter((filePath) => !filePath.endsWith('.test.ts'))
    .filter((filePath) => !filePath.endsWith('_routes_.ts'));

  const allRows = [];
  for (const filePath of apiFiles) {
    const text = await readFile(filePath, 'utf8');
    const endpoints = parseEndpointsFromFile(filePath, text, mountedFiles.has(path.normalize(filePath)));
    const source = toPosix(path.relative(repoRoot, filePath));
    for (const endpoint of endpoints) {
      allRows.push({
        method: endpoint.method,
        path: endpoint.fullPath,
        source,
        handler: `L${endpoint.line}`,
      });
    }
  }

  const dedup = new Map();
  for (const row of allRows) {
    const key = `${row.method}|${row.path}|${row.source}|${row.handler}`;
    if (!dedup.has(key)) dedup.set(key, row);
  }

  const sortedRows = Array.from(dedup.values()).sort((a, b) => {
    if (a.path !== b.path) return a.path.localeCompare(b.path);
    if (a.method !== b.method) return a.method.localeCompare(b.method);
    if (a.source !== b.source) return a.source.localeCompare(b.source);
    return a.handler.localeCompare(b.handler);
  });

  await mkdir(path.dirname(outRuPath), {recursive: true});
  await mkdir(path.dirname(outEnPath), {recursive: true});

  await writeFile(outRuPath, renderRuMarkdown(sortedRows), 'utf8');
  await writeFile(outEnPath, renderEnMarkdown(sortedRows), 'utf8');

  console.log(`Generated API docs with ${sortedRows.length} endpoints.`);
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
